{"meta":{"title":"预见未来","subtitle":null,"description":null,"author":"LiJunkui","url":"https://lijunkui.netlify.com","root":"/"},"pages":[{"title":"分类","date":"2018-12-22T05:45:03.000Z","updated":"2018-12-22T06:54:20.000Z","comments":true,"path":"category/index.html","permalink":"https://lijunkui.netlify.com/category/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-22T03:30:49.000Z","updated":"2018-12-22T06:54:08.000Z","comments":true,"path":"tagcloud/index.html","permalink":"https://lijunkui.netlify.com/tagcloud/index.html","excerpt":"","text":""}],"posts":[{"title":"Naive Bayes Classifier","slug":"朴素贝叶斯","date":"2019-03-25T06:20:21.000Z","updated":"2019-03-25T13:01:20.000Z","comments":true,"path":"2019/03/25/朴素贝叶斯/","link":"","permalink":"https://lijunkui.netlify.com/2019/03/25/朴素贝叶斯/","excerpt":"在机器学习领域中，朴素贝叶斯是一种基于贝叶斯定理的简单概率分类器, 朴素贝叶斯在处理文本数据时可以得到较好的分类结果，被广泛应用于文本分类/垃圾邮件过滤/自然语言处理等场景。","text":"在机器学习领域中，朴素贝叶斯是一种基于贝叶斯定理的简单概率分类器, 朴素贝叶斯在处理文本数据时可以得到较好的分类结果，被广泛应用于文本分类/垃圾邮件过滤/自然语言处理等场景。 使用Python进行文本分类判断某句话是否为正常言论导入数据12345678910def loadDataSet(): postingList = [['my', 'dog', 'has', 'flea', 'problems', 'help', 'please'], ['maybe', 'not', 'take', 'him', 'to', 'dog', 'park', 'stupid'], ['my', 'dalmation', 'is', 'so', 'cute', 'I', 'love', 'him'], ['stop', 'posting', 'stupid', 'worthless', 'garbage'], ['mr', 'licks', 'ate', 'my', 'steak','how', 'to', 'stop', 'him'], ['quit', 'buying', 'worthless', 'dog', 'food', 'stupid']] classVec = [0, 1, 0, 1, 0, 1] # 1 侮辱性文字, 0 正常言论 return postingList, classVec 创建字典12345def createVocabList(dataSet): vocabSet = set([]) # create empty set for document in dataSet: vocabSet = vocabSet | set(document) # union of the two sets return list(vocabSet) 将某句话转换为向量123456789def setOfWords2Vec(vocabList, inputSet): returnVec = [0]*len(vocabList) for word in inputSet: if word in vocabList: returnVec[vocabList.index(word)] = 1 #词集模型 某个单词只能出现一次 else: print(\"the word: %s is not in my Vocabulary!\" % word) return returnVec 从词向量计算概率12from numpy import *import math 123456789101112131415161718def trainNB0(trainMatrix, trainCategory): numTrainDocs = len(trainMatrix) numWords = len(trainMatrix[0]) pAbusive = sum(trainCategory)/float(numTrainDocs) p0Num = ones(numWords) p1Num = ones(numWords) # change to ones() p0Denom = 2.0 p1Denom = 2.0 # change to 2.0 for i in range(numTrainDocs): if trainCategory[i] == 1: p1Num += trainMatrix[i] p1Denom += sum(trainMatrix[i]) else: p0Num += trainMatrix[i] p0Denom += sum(trainMatrix[i]) p1Vect = log(p1Num/p1Denom) # change to log() p0Vect = log(p0Num/p0Denom) # change to log() return p0Vect, p1Vect, pAbusive 参考文档","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://lijunkui.netlify.com/tags/Python/"},{"name":"DL","slug":"DL","permalink":"https://lijunkui.netlify.com/tags/DL/"},{"name":"NLP","slug":"NLP","permalink":"https://lijunkui.netlify.com/tags/NLP/"}]},{"title":"Git使用","slug":"git使用","date":"2019-03-15T11:37:00.000Z","updated":"2019-03-20T13:11:32.000Z","comments":true,"path":"2019/03/15/git使用/","link":"","permalink":"https://lijunkui.netlify.com/2019/03/15/git使用/","excerpt":"Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理","text":"Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理 分支操作相关命令1.查看本地分支 1git branch 2.查看远程分之 12git branch -agit branch -r 如果你知道,请告诉我区别 3.创建本地分支 1git branch EXAMPLE 4.切换分支 1git checkout EXAMPLE 5.创建新分支并切换到新分支 1git checkout -b EXAMPLE 6.删除本地分支 1git branch -d EXAMPLE 我将origin作为了远程仓库的名字 7.创建远程分支 1git push origin EXAMPLE 8.删除远程(origin)分支 1git push origin --delete EXAMPLE 9.添加远程仓库 1git remote add origin 地址 地址可以是HTTPS或者SSH 参考文档 我曾出现的问题1error:src refspec master does not match any 解决:引起该错误的原因是，目录中没有文件，空目录是不能提交上去的，而且在push之前至少有过一次commit 123456git init git touch README git add README git commit -m &apos;first commit&apos;git remote add origin 地址git push origin master","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://lijunkui.netlify.com/tags/Git/"}]},{"title":"Note","slug":"笔记","date":"2019-03-04T13:31:30.000Z","updated":"2019-04-12T12:07:04.146Z","comments":true,"path":"2019/03/04/笔记/","link":"","permalink":"https://lijunkui.netlify.com/2019/03/04/笔记/","excerpt":"C++ Python STL ACM LeetCode 数据结构","text":"C++ Python STL ACM LeetCode 数据结构 CPP方向 for循环的这种用法 1234vector&lt;int&gt; nums = &#123;1, 2, -1, -2, -3, 0&#125;; for (int c : nums) cout &lt;&lt; c; cout &lt;&lt; endl; substr()函数返回字符串的某个区间内元素例如str.substr(2,4):从下标为2的元素开始(包括下标为2的元素)往后的四个元素 1234567891011string FindQZ(vector&lt;string&gt; &amp;str) &#123; int result = 0; for (; result &lt; str[0].size(); ++result) &#123; char checker = str[0][result]; for (int i = 1; i &lt; str.size(); ++i) &#123; if (checker != str[i][result]) return str[0].substr(0, result); &#125; &#125; return str[0].substr(0, result);&#125; 123456789101112131415161718// CPP program to illustrate substr() #include &lt;string.h&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; vector&lt;string&gt; str = &#123;\"i\", \"am\", \"lijunkui\"&#125;; //区分与vector&lt;char&gt; x=&#123;'i','a','m','l'&#125;; cout &lt;&lt; str[2].substr(2, 3) &lt;&lt; endl; string s = \"lijunkui\"; cout &lt;&lt; s.substr(1, 2) &lt;&lt; endl; string a = s.substr(1, 2); cout &lt;&lt; a &lt;&lt; endl; return 0; &#125; &gt;&gt;&gt; jun&gt;&gt;&gt; ij&gt;&gt;&gt; ij accumulate()累加求和函数 12int sum = accumulate(vec.begin() , vec.end() , 42); accumulate带有三个形参：头两个形参指定要累加的元素范围，第三个形参则是累加的初值。 reverse()函数 1reverse(digits.begin(), digits.end()); find()函数 12345678910111213141516171819//容器表示方法find（a.begin(),a.end(),value）//数组的表示方法find（a,a+length,val）//对于string，通过a.find(val)==string::npos判断string str = \"hello world\"; char ch = 'l'; if(str.find(ch)!=string::npos)&#123; //查找单个字符 cout&lt;&lt;str.find(ch)&lt;&lt;endl; &#125; else cout&lt;&lt;\"NO\"&lt;&lt;endl; int p = 0;//表示第0个位置开始while(str.find(ch, p)!=string::npos)&#123; p = str.find(ch, p); cout&lt;&lt;p&lt;&lt;endl; p = p + 1; &#125; distance()函数返回容器中两个地址之间的距离 12345//注意:这里是闭区间 vector&lt;int&gt; numbers = &#123;0, 0, 3, 4&#125;; cout &lt;&lt; distance(numbers.begin(), numbers.end()) &lt;&lt; endl; cout &lt;&lt; numbers.end() - numbers.begin() &lt;&lt; endl; 输出:4 unique(it_1，it_2)函数,表示对容器中[it_1，it_2)范围的元素进行去重(注：区间是前闭后开，即不包含it_2所指的元素),返回值是一个迭代器，它指向的是去重后容器中不重复序列的最后一个元素的下一个元素。 erase(first,last);删除从first到last之间的字符（first和last都是迭代器） 123456789int removeDuplicates(vector&lt;int&gt; &amp;nums) &#123; int dup = 0; // unique的作用是将容器中相邻元素的重复元素至尾 vector&lt;int&gt;::iterator it = unique(nums.begin(), nums.end()); dup = it - nums.begin(); cout &lt;&lt; \"it=\" &lt;&lt; *it &lt;&lt; endl; nums.erase(it, nums.end()); //删除 从it位置开始到end结束 return dup;&#125; 12345678910111213141516171819//这两种方法是针对字符串的#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main ()&#123; string str (\"This is an example phrase.\"); string::iterator it; // 第(1)种用法 str.erase (10,8); cout &lt;&lt; str &lt;&lt; endl; // \"This is an phrase.\" // 第(2)种用法 it=str.begin()+9; str.erase (it); cout &lt;&lt; str &lt;&lt; endl; // \"This is a phrase.\"&#125; Python方向python3 读写Excel 2007版以前的Excel（xls结尾的），需要使用xlrd读，xlwt写。 2007版以后的Excel（xlsx结尾的），需要使用openpyxl来读写。 参考文档 1234567891011121314151617181920# Reading an excel file using Python import xlrd # Give the location of the file loc = (\"path of file\") # To open Workbook wb = xlrd.open_workbook(loc) sheet = wb.sheet_by_index(0) # For row 0 and column 0 sheet.cell_value(0, 0)# Extracting number of rows print(sheet.nrows) # Extracting number of columns print(sheet.ncols)#Extract a particular row or valueprint(sheet.row_values(1))print(sheet.col_values(2))# For row and columnfor r in range(sheet.nrows): for c in range(sheet.ncols): print(sheet.cell_value(r, c)) ACM1.整数与罗马数字的转换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include \"iostream\"#include \"string\"#include \"unordered_map\"#include \"vector\"using namespace std;//罗马数字转至整数int romanToInt(string s) &#123; unordered_map&lt;char, int&gt; T = &#123;&#123;'I', 1&#125;, &#123;'V', 5&#125;, &#123;'X', 10&#125;, &#123;'L', 50&#125;, &#123;'C', 100&#125;, &#123;'D', 500&#125;, &#123;'M', 1000&#125;&#125;; int sum = T[s.back()]; //无向图最后一个元素的值 for (int i = s.length() - 2; i &gt;= 0; --i) &#123; if (T[s[i]] &lt; T[s[i + 1]]) //当左边元素的值小于右边元素的值 必然是相减的关系 sum -= T[s[i]]; else sum += T[s[i]]; &#125; return sum; //整数转至罗马数字 string InttoRoman(int num) &#123; string res = \"\"; char roman[] = &#123;'M', 'D', 'C', 'L', 'X', 'V', 'I'&#125;; int value[] = &#123;1000, 500, 100, 50, 10, 5, 1&#125;; // 7表示最大为4位数,n=+2表示从个位十位百位开始计算 for (int n = 0; n &lt; 7; n += 2) &#123; int x = num / value[n]; if (x &lt; 4) &#123; for (int i = 1; i &lt;= x; ++i) res += roman[n]; &#125; else if (x == 4) res = res + roman[n] + roman[n - 1]; else if (x &gt; 4 &amp;&amp; x &lt; 9) &#123; res += roman[n - 1]; for (int i = 6; i &lt;= x; ++i) res += roman[n]; &#125; else if (x == 9) res = res + roman[n] + roman[n - 2]; num %= value[n]; &#125; return res;&#125;int main(int argc, char const *argv[]) &#123; string test1 = \"MCMXCIV\"; cout &lt;&lt; romanToInt(test1) &lt;&lt; endl; int number1 = 1994; cout &lt;&lt; InttoRoman(number1) &lt;&lt; endl; return 0; 整数转至罗马数字解法二 12345678910111213string InttoRoman2(int num) &#123; string res = \"\"; vector&lt;int&gt; val&#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;; vector&lt;string&gt; str&#123;\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"&#125;; for (int i = 0; i &lt; val.size(); ++i) &#123; while (num &gt;= val[i]) &#123; //确定num在哪一个阶段 num -= val[i]; //向下一个较小阶段逼近 res += str[i]; //叠加相对应的字符 &#125; &#125; return res;&#125; 此处有问题:vector val向量有什么选择要求?应该怎样选择?为什么要这样选? 2.任务调度器 123456789101112131415161718192021222324#include \"algorithm\"#include \"iostream\"#include \"unordered_map\"#include \"vector\"using namespace std;int leastInterval(vector&lt;char&gt; &amp;tasks, int n) &#123; unordered_map&lt;char, int&gt; mp; int count = 0; for (auto e : tasks) &#123; mp[e]++; cout &lt;&lt; e &lt;&lt; \" \" &lt;&lt; mp[e] &lt;&lt; endl; count = max(count, mp[e]); &#125; int ans = (count - 1) * (n + 1); for (auto e : mp) if (e.second == count) ans++; return max((int)tasks.size(), ans);&#125;int main(int argc, char const *argv[]) &#123; vector&lt;char&gt; tasks = &#123;'A', 'C', 'A', 'A', 'A', 'B', 'B', 'B', 'C', 'C'&#125;; cout &lt;&lt; leastInterval(tasks, 2) &lt;&lt; endl; return 0;&#125; 三角形最小路径和 从底至上，堪称完美 1234for (int i = triangle.size() - 2; i &gt;= 0; i--) for (int j = 0; j &lt; triangle[i].size(); j++)triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j+1]); return triangle[0][0]; 算法列表 贪心算法 贪心算法（英语：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。 mapMap是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力。map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的 头文件 1#include \"iostream\" 构造函数 1map&lt;TYPE,TYPE&gt; MAPNAME; 123map&lt;int,int&gt; one;map&lt;int,string&gt; twe;map&lt;string,int&gt; three; pairpair是将2个数据组合成一个数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。 pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。 12345678910111213141516171819202122232425262728293031// C++ program to demonstrate sorting in // vector of pair according to 1st element of pair #include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; // Declaring vector of pairs vector&lt; pair &lt;int,int&gt; &gt; vect; // Initializing 1st and 2nd element of // pairs with array values int arr[] = &#123;10, 20, 5, 40 &#125;; int arr1[] = &#123;30, 60, 20, 50&#125;; int n = sizeof(arr)/sizeof(arr[0]); // Entering values in vector of pairs for (int i=0; i&lt;n; i++) vect.push_back( make_pair(arr[i],arr1[i]) ); // Using simple sort() function to sort sort(vect.begin(), vect.end()); // Using sort() function to sort by 2nd element of pair sort(vect.begin(), vect.end(), sortbysec); // Printing the sorted vector(after using sort()) for (int i=0; i&lt;n; i++) &#123; // \"first\" and \"second\" are used to access // 1st and 2nd element of pair respectively cout &lt;&lt; vect[i].first &lt;&lt; \" \" &lt;&lt; vect[i].second &lt;&lt; endl; &#125; return 0; &#125; 构造函数 123pair&lt;int, double&gt; p1; //使用默认构造函数pair&lt;int, double&gt; p2(1, 2.4); //用给定值初始化pair&lt;int, double&gt; p3(p2); //拷贝构造函数 make_pair 函数 12pair&lt;int, double&gt; p1;p1 = make_pair(1, 1.2); 递归递归算法是一种直接或者间接调用自身函数或者方法的算法。 注意:递归内部采用栈的形式 案例一:求阶乘 案例二:汉诺塔问题 123456789void Hanoi(int n, char A, char B, char C) &#123; if (n == 1) cout &lt;&lt; \" from \" &lt;&lt; A &lt;&lt; \" to \" &lt;&lt; C &lt;&lt; \", \"; else &#123; Hanoi(n - 1, A, C, B); cout &lt;&lt; \" from \" &lt;&lt; A &lt;&lt; \" to \" &lt;&lt; C &lt;&lt; \", \"; Hanoi(n - 1, B, A, C); &#125;&#125; On March 29NLTK Natural Language Toolkitchatbot工作原理提问处理模块、检索模块、答案抽取模块。 提问处理模块要做三项重要工作：查询关键词生成、答案类型确定、句法和语义分析。 查询关键词生成，就是从你的提问中提取出关键的几个关键词，因为我本身是一个空壳子，需要去网上查找资料才能回答你，而但网上资料那么多，我该查哪些呢？所以你的提问就有用啦，我找几个中心词，再关联出几个扩展词，上网一搜，一大批资料就来啦，当然这些都是原始资料，我后面要继续处理。再说答案类型确定，这项工作是为了确定你的提问属于哪一类的，如果你问的是时间、地点，和你问的是技术方案，那我后面要做的处理是不一样的。最后再说这个句法和语义分析，这是对你问题的深层含义做一个剖析，比如你的问题是：聊天机器人怎么做？那么我要知道你要问的是聊天机器人的研发方法 检索模块跟搜索引擎比较像，就是根据查询关键词所信息检索，返回句子或段落，这部分就是下一步要处理的原料 答案抽取模块可以说是计算量最大的部分了，它要通过分析和推理从检索出的句子或段落里抽取出和提问一致的实体，再根据概率最大对候选答案排序，注意这里是“候选答案”噢，也就是很难给出一个完全正确的结果，很有可能给出多个结果，最后还在再选出一个来 reload()1234567#方法一import sysimport importlibimportlib.reload(sys)#方法二from imp import reloadimp.reload('regTrees') 命名实体识别（英语：Named Entity Recognition，简称NER），又称作专名识别、命名实体，是指识别文本中具有特定意义的实体，主要包括人名、地名、机构名、专有名词等，以及时间、数量、货币、比例数值等文字。指的是可以用专有名词（名称）标识的事物，一个命名实体一般代表唯一一个具体事物个体，包括人名、地名等。 NER属于从非结构化文本中分类和定位命名实体感情的子任务，其过程是从是非结构化文本表达式中产生专有名词标注信息的命名实体表达式，目前NER有两个显著的问题，即识别和分类。例如，“奥巴马是美国总统”的“奥巴马”和“美国”都代表一个具体事物，因此都是命名实体。而“总统”不代表一个具体事物，因此不是命名实体。 pynlpir licence 问题或者有以下报错1RuntimeError(\"NLPIR function 'NLPIR_Init' failed.\") 解决办法1sudo pynlpir update pynlpir基本用法 依存句法分析依存语法 (Dependency Parsing, DP) 通过分析语言单位内成分之间的依存关系揭示其句法结构。 直观来讲，依存句法分析识别句子中的“主谓宾”、“定状补”这些语法成分，并分析各成分之间的关系。 语义依存分析语义依存分析 (Semantic Dependency Parsing, SDP)，分析句子各个语言单位之间的语义关联，并将语义关联以依存结构呈现。 使用语义依存刻画句子语义，好处在于不需要去抽象词汇本身，而是通过词汇所承受的语义框架来描述该词汇，而论元的数目相对词汇来说数量总是少了很多的。语义依存分析目标是跨越句子表层句法结构的束缚，直接获取深层的语义信息。 参考文档 docker介绍 chatterbot12345678910111213141516from chatterbot import ChatBotchatbot = ChatBot(\"Ron Obvious\")from chatterbot.trainers import ListTrainerconversation = [ \"Hello\", \"Hi there!\", \"How are you doing?\", \"I'm doing great.\", \"That is good to hear\", \"Thank you.\", \"You're welcome.\"]chatbot.set_trainer(ListTrainer)chatbot.train(conversation) 报错信息 1AttributeError: 'ChatBot' object has no attribute 'set_trainer' 解决办法 123456789101112131415from chatterbot.trainers import ListTrainerconversation = [ \"Hello\", \"Hi there!\", \"How are you doing?\", \"I'm doing great.\", \"That is good to hear\", \"Thank you.\", \"You're welcome.\"]trainer = ListTrainer(chatbot)trainer.train(conversation) https://github.com/gunthercox/ChatterBot/issues/1555 报错信息 1Resource averaged_perceptron_tagger not found. 解决办法 https://github.com/vivekkalyanarangan30/Text-Clustering-API/issues/1 On April 2vector 初始化12345678910vector&lt;int&gt; vec; //声明一个int型向量vector&lt;int&gt; vec(5); //声明一个初始大小为5的int向量vector&lt;int&gt; vec(10, 1); //声明一个初始大小为10且值都是1的向量vector&lt;int&gt; vec(tmp); //声明并用tmp向量初始化vec向量vector&lt;int&gt; tmp(vec.begin(), vec.begin() + 3); //用向量vec的第0个到第2个值初始化tmpint arr[5] = &#123;1, 2, 3, 4, 5&#125;; vector&lt;int&gt; vec(arr, arr + 5); //将arr数组的元素用于初始化vec向量//说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，//这个主要是为了和vec.end()指针统一。vector&lt;int&gt; vec(&amp;arr[1], &amp;arr[4]); //将arr[1]~arr[4]范围内的元素作为vec的初始值 https://www.cnblogs.com/zhonghuasong/p/5975979.html On April 3深度优先与广度优先https://www.cnblogs.com/skywang12345/p/3711483.html 树定义 树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。 特点 每个节点都只有有限个子节点或无子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树； 树里面没有环路 术语 节点的度：一个节点含有的子树的个数称为该节点的度； 树的度：一棵树中，最大的节点的度称为树的度； 叶节点或终端节点：度为零的节点； 非终端节点或分支节点：度不为零的节点； 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 兄弟节点：具有相同父节点的节点互称为兄弟节点； 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推； 深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0； 高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0； 堂兄弟节点：父节点在同一层的节点互为堂兄弟； 节点的祖先：从根到该节点所经分支上的所有节点； 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。 森林：由m（m&gt;=0）棵互不相交的树的集合称为森林； 种类 无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树； 有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树； 二叉树：每个节点最多含有两个子树的树称为二叉树； 完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树； 满二叉树：所有叶节点都在最底层的完全二叉树； 平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树； 排序二叉树(二叉查找树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树； 霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树； B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。 遍历 深度优先遍历 前序遍历(Pre-Order Traversal)) 1234567void pre_order_traversal(TreeNode *root) &#123; // Do Something with root if (root-&gt;lchild != NULL) pre_order_traversal(root-&gt;lchild); if (root-&gt;rchild != NULL) pre_order_traversal(root-&gt;rchild);&#125; 中序遍历(In-Order Traversal)) 1234567void in_order_traversal(TreeNode *root) &#123; if (root-&gt;lchild != NULL) in_order_traversal(root-&gt;lchild); // Do Something with root if (root-&gt;rchild != NULL) in_order_traversal(root-&gt;rchild);&#125; 后序遍历(Post-Order Traversal)) 123456void post_order_traversal(TreeNode *root) &#123; if (root-&gt;lchild != NULL) post_order_traversal(root-&gt;lchild); if (root-&gt;rchild != NULL) post_order_traversal(root-&gt;rchild); // Do Something with root 广度优先遍历 12345678910111213141516171819202122232425void Layer_Traver(tree *root) &#123; int head = 0, tail = 0; tree *p[SIZE] = &#123;NULL&#125;; tree *tmp; if (root != NULL) &#123; p[head] = root; tail++; // Do Something with p[head] &#125; else return; while (head &lt; tail) &#123; tmp = p[head]; // Do Something with p[head] if (tmp-&gt;left != NULL) &#123; // left p[tail] = tmp-&gt;left; tail++; &#125; if (tmp-&gt;right != NULL) &#123; // right p[tail] = tmp-&gt;right; tail++; &#125; head++; &#125; return;&#125; 最简单的划分：是深度优先（先访问子节点，再访问父节点，最后是第二个子节点）？还是广度优先（先访问第一个子节点，再访问第二个子节点，最后访问父节点）？ 深度优先可进一步按照根节点相对于左右子节点的访问先后来划分。如果把左节点和右节点的位置固定不动，那么根节点放在左节点的左边，称为前序（pre-order）、根节点放在左节点和右节点的中间，称为中序（in-order）、根节点放在右节点的右边，称为后序（post-order）。对广度优先而言，遍历没有前序中序后序之分：给定一组已排序的子节点，其“广度优先”的遍历只有一种唯一的结果。 性质 二叉树第i层上的结点数目最多为 2{i-1} (i≥1) 深度为k的二叉树至多有2{k}-1个结点(k≥1) 包含n个结点的二叉树的高度至少为log2 (n+1) 对于任意一个编号为n的节点，如果它有子节点，它的左子节点编号为2n,右节点的编号为2n+1 顺序存储1234567891011121314151617181920212223242526//二叉树的先序输入与输出#include &lt;stdio.h&gt;void get_tree(char*,int);void print_tree(char*,int);int main()&#123; char tree[1000]; get_tree(tree,1); print_tree(tree,1); return 0;&#125;void get_tree(char *tree,int sub)&#123; char t; scanf(\"%c\",&amp;t); tree[sub]=t; if(t=='#') return; get_tree(tree,2*sub); get_tree(tree,2*sub+1);&#125;void print_tree(char *tree,int sub)&#123; if(tree[sub]=='#') return; printf(\"%c\",tree[sub]); print_tree(tree,2*sub); print_tree(tree,2*sub+1);&#125; 链式存储https://www.cnblogs.com/chenliyang/p/6553128.html 节点描述 12345typedef struct BiTNode&#123; TElemType data; struct BiTNode *lchild,*rchild; &#125;BiTNode,*BiTree; 创建链式二叉树 12345678910111213void createBitree(Bitree &amp;T)&#123; char ch; if((ch=getchar())=='#') T=NULL; else &#123; T=(Bitnode*)malloc(sizeof(Bitnode)); T-&gt;data=ch; createBitree(T-&gt;Lchild); createBitree(T-&gt;Rchild); &#125;&#125; 遍历二叉树 12345678910/*先序遍历*/void preTraverse(Bitree T)&#123; if(T!=NULL) &#123; printf(\"%c\",T-&gt;data); preTraverse(T-&gt;Lchild); preTraverse(T-&gt;Rchild); &#125;&#125; 12345678910/*中序遍历*/void inorder(Bitree T)&#123; if(T!=NULL) &#123; inorder(T-&gt;Lchild); printf(\"%c\",T-&gt;data); inorder(T-&gt;Rchild); &#125; &#125; 1234567891011/*后序遍历*/void postorder(Bitree T)&#123; if(T!=NULL)&#123;postorder(T-&gt;lchild);postorder(T-&gt;rchild);printf(\"%c\",T-&gt;data); &#125;&#125; 二叉树的深度 12345678910111213int Depth(Bitree T)&#123;//返回深度 int d,dl,dr; if(!T) d=0; else &#123; dl=Depth(T-&gt;Lchild); dr=Depth(T-&gt;Rchild); d=1+(dl&gt;dr?dl:dr) ; &#125; return d;&#125; 二叉树的层序遍历 123456789101112131415161718queue&lt;Bitree&gt; TreeQueue; //使用队列 TreeQueue.push(tree); //先将队头元素加入队列 Bitree p = tree; while (!TreeQueue.empty()) //循环判断队列是否未空，若不空则 &#123; p = TreeQueue.front(); //获取队列头节点，并出队列 TreeQueue.pop(); printf(\" %c \", p-&gt;data); //打印队列元素 if (p-&gt;Lchild) //如果该节点有左节点 &#123; TreeQueue.push(p-&gt;Lchild); //加入队列 &#125; if (p-&gt;Rchild) //如果该节点有右节点 &#123; TreeQueue.push(p-&gt;Rchild); //加入队列 &#125; &#125; 结构体的几种形式https://blog.csdn.net/mengxiangjia_linxi/article/details/78168461 先定义结构体类型，再定义结构体类型变量 1234567struct stu &#123; char name[20]; //学生姓名 char sex; //性别 long num; //学号 float score[3]; //三科考试成绩&#125;; 1struct stu student1,student2;//struct stu 此时相当于int , char 定义结构体类型同时定义结构体类型变量 123456struct data&#123; int day; int month; int year;&#125; time1,time2; 1struct data time3,time4;//struct data 此时相当于int , char 定义一个结构体类型用typedef 12345typedef struct Student&#123; char name; int a;&#125;Stu; 1Stu stu1;//Stu 相当于struct Student , 而不能用 Student stu1 这种形式","categories":[{"name":"CPP方向","slug":"CPP方向","permalink":"https://lijunkui.netlify.com/categories/CPP方向/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://lijunkui.netlify.com/tags/Python/"},{"name":"C++","slug":"C","permalink":"https://lijunkui.netlify.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://lijunkui.netlify.com/tags/STL/"},{"name":"ACM","slug":"ACM","permalink":"https://lijunkui.netlify.com/tags/ACM/"}]},{"title":"神经网络","slug":"神经网络","date":"2019-03-03T11:23:29.000Z","updated":"2019-03-17T03:56:48.000Z","comments":true,"path":"2019/03/03/神经网络/","link":"","permalink":"https://lijunkui.netlify.com/2019/03/03/神经网络/","excerpt":"设计一个神经网络时，输入层与输出层的节点数往往是固定的，中间层则可以自由指定； 神经网络结构图中的拓扑与箭头代表着预测过程时数据的流向，跟训练时的数据流有一定的区别； 圆圈（代表“神经元”），连接线（代表“神经元”之间的连接）。每个连接线对应一个不同的权重（其值称为权值），这是需要训练得到的。","text":"设计一个神经网络时，输入层与输出层的节点数往往是固定的，中间层则可以自由指定； 神经网络结构图中的拓扑与箭头代表着预测过程时数据的流向，跟训练时的数据流有一定的区别； 圆圈（代表“神经元”），连接线（代表“神经元”之间的连接）。每个连接线对应一个不同的权重（其值称为权值），这是需要训练得到的。 相关链接https://blog.csdn.net/illikang/article/details/82019945","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://lijunkui.netlify.com/categories/深度学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://lijunkui.netlify.com/tags/Python/"},{"name":"DL","slug":"DL","permalink":"https://lijunkui.netlify.com/tags/DL/"}]},{"title":"决策树","slug":"决策树","date":"2019-03-02T00:24:06.000Z","updated":"2019-03-22T05:49:28.000Z","comments":true,"path":"2019/03/02/决策树/","link":"","permalink":"https://lijunkui.netlify.com/2019/03/02/决策树/","excerpt":"机器学习中，决策树是一个预测模型；他代表的是对象属性与对象值之间的一种映射关系。树中每个节点表示某个对象，而每个分叉路径则代表某个可能的属性值，而每个叶节点则对应从根节点到该叶节点所经历的路径所表示的对象的值。决策树仅有单一输出，若欲有复数输出，可以建立独立的决策树以处理不同输出。 数据挖掘中决策树是一种经常要用到的技术，可以用于分析数据，同样也可以用来作预测。","text":"机器学习中，决策树是一个预测模型；他代表的是对象属性与对象值之间的一种映射关系。树中每个节点表示某个对象，而每个分叉路径则代表某个可能的属性值，而每个叶节点则对应从根节点到该叶节点所经历的路径所表示的对象的值。决策树仅有单一输出，若欲有复数输出，可以建立独立的决策树以处理不同输出。 数据挖掘中决策树是一种经常要用到的技术，可以用于分析数据，同样也可以用来作预测。 简介决策论中 （如风险管理），决策树（Decision tree）由一个决策图和可能的结果（包括资源成本和风险）组成， 用来创建到达目标的规划。决策树建立并用来辅助决策，是一种特殊的树结构。决策树是一个利用像树一样的图形或决策模型的决策支持工具，包括随机事件结果，资源代价和实用性。它是一个算法显示的方法。决策树经常在运筹学中使用，特别是在决策分析中，它帮助确定一个能最可能达到目标的策略。如果在实际中，决策不得不在没有完备知识的情况下被在线采用，一个决策树应该平行概率模型作为最佳的选择模型或在线选择模型算法。决策树的另一个使用是作为计算条件概率的描述性手段。 信息论克劳德·艾尔伍德·香农（Claude Elwood Shannon ，1916年4月30日—2001年2月24日）美国数学家、信息论的创始人。 信息量信息量在是作为信息“多少”的度量，这里的信息就是你理解的信息，比如一条新闻，考试答案等等。假设我们听到了两件事，分别如下： 事件A：巴西队进入了2018世界杯决赛圈。 事件B：中国队进入了2018世界杯决赛圈。 仅凭直觉来说，事件B的信息量比事件A的信息量要大。究其原因，是因为事件A发生的概率很大，事件B发生的概率很小。所以当越不可能的事件发生了，我们获取到的信息量就越大。越可能发生的事件发生了，我们获取到的信息量就越小。那么： 信息量和事件发生的概率相关，事件发生的概率越低，传递的信息量越大 信息量应当是非负的，必然发生的事件的信息量为零（必然事件是必然发生的，所以没有信息量。几乎不可能事件一旦发生，具有近乎无穷大的信息量） 两个事件的信息量可以相加，并且两个独立事件的联合信息量应该是他们各自信息量的和 如已知事件Xi已发生，则表示Xi所含有或所提供的信息量： 如果是以2为底数，单位是bit；如果以e为底数，单位是nat；如果以10为底数，单位是det 信息熵信息熵（Entropy）是接受信息量的平均值，用于确定信息的不确定程度，是随机变量的均值。信息熵越大，信息就越凌乱或传输的信息越多, 信息熵的处理信息是一个让信息的熵减少的过程。 假设X是一个离散的随机变量，且它的取值范围为{x_1, x_1, …, x_n}，每一种取到的概率分别是 {p_1,p_1,…,p_n}，那么 X 的熵定义为: 信息增益信息熵表示的是不确定度。均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，分类后的数据集信息熵会比分类前的小，其差值表示为信息增益。信息增益（Kullback-Leibler divergence）用于度量属性A对降低样本集合X熵的贡献大小。信息增益可以衡量某个特征对分类结果的影响大小。信息增益越大，越适用对X进行分析。 ID3算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from math import logimport operator#创建数据集def createData(): dataSet = [[1, 1, 'yes'], [1, 1, 'yes'], [ 1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']] labels = ['no surfacing', 'flippers'] return dataSet, labels#计算信息熵def calcShannonEnt(dataSet): dataSetLen = len(dataSet) labelsCount = &#123;&#125; for everydata in dataSet: currentLabel = everydata[-1] if currentLabel not in labelsCount.keys(): labelsCount[currentLabel] = 0 labelsCount[currentLabel] += 1 ShannonEnt = 0.0 for key in labelsCount: prob = float(labelsCount[key])/dataSetLen ShannonEnt -= prob*log(prob, 2) return ShannonEnt#切分数据集#dataDat表示待划分的数据集,axis表示划分数据集的特征,value表示需要返回的特征的值def spliDataSet(dataSet, axis, value): retDataSet = [] for featVec in dataSet: if featVec[axis] == value: reducedFeatVec = featVec[:axis] reducedFeatVec.extend(featVec[axis+1:]) retDataSet.append(reducedFeatVec) return retDataSet#选择最佳特征切分数据集def chooseBestFeatureToSplit(dataSet): numFeatures = len(dataSet[0])-1 baseEntropy = calcShannonEnt(dataSet) bestInfoGain = 0.0 bestFeature = -1 for i in range(numFeatures): featList = [example[i] for example in dataSet] uniqueVals = set(featList) newEntropy = 0.0 for value in uniqueVals: subDataSet = spliDataSet(dataSet, i, value) prob = len(subDataSet)/float(len(dataSet)) newEntropy += prob*calcShannonEnt(subDataSet) infoGain = baseEntropy-newEntropy if(infoGain &gt; bestInfoGain): bestInfoGain = infoGain bestFeature = i return bestFeature 笔记1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#python中的for循环&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]: print(x,y)149&gt;&gt;&gt; for x, y in enumerate(['a', 'b', 'c']): print(x, y)abc1.列出1到10的平方列表L=[]for x in range(1,11): L.append(x*x)print(L)[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]#python提供了更简便的方法处理这个需求&gt;&gt;&gt; [x*x for x in range(1,11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]2.添加判断条件只取列表中的偶数&gt;&gt;&gt; [x*x for x in range(1,11) if x%2==0][4, 16, 36, 64, 100]3.多个for同时判断&gt;&gt;&gt; [m+n for m in 'ABC' for n in'abc']['Aa', 'Ab', 'Ac', 'Ba', 'Bb', 'Bc', 'Ca', 'Cb', 'Cc']#Python list 中的冒号[m : ] 代表列表中的第m+1项到最后一项[ : n] 代表列表中的第一项到第n项 m = 3 n = 6 aa = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] a = aa[m : ] b = aa[ : n] c = aa[m : n] print(a) print(b) print(c) [3, 4, 5, 6, 7, 8, 9][0, 1, 2, 3, 4, 5][3, 4, 5]双冒号的情况list[start:end:step]start:起始位置 end:结束位置 step:步长&gt;&gt;&gt; range(100)[20:30:2][20, 22, 24, 26, 28]#extend()与append()方法的不同&gt;&gt;&gt;a=[1,2,3]&gt;&gt;&gt;b=[4,5,6]&gt;&gt;&gt;a.append(b)&gt;&gt;&gt;a[1,2,3,[4,5,6]]&gt;&gt;&gt;a.extend(b)[1,2,3,4,5,6] 参考文档 sklearn决策树可视化 scikit-learn 中决策树的可视化需要安装 graphviz 请不要使用这种方式否则会有报错 1sudo pip install graphviz 正确方式请到graphviz下载对应版本并解压包运行以下命令 123./configuremakemake install 关于源代码编译安装程序的流程 方法一 export_graphviz 将树导出为 Graphviz 格式 123456789from sklearn import treefrom sklearn.datasets import load_iris #载入sklearn中自带的数据Iris，构造决策树iris=load_iris()clf=tree.DecisionTreeClassifier()clf=clf.fit(iris.data,iris.target)#训练完成后，我们可以用 export_graphviz 将树导出为 Graphviz 格式with open(\"iris.dot\", 'w') as f: f = tree.export_graphviz(clf, out_file=f) 此时已经在本地生成了 iris.dot 文件，在命令行输入 dot -Tpdf iris.dot -o iris.pdf 生成决策树的PDF可视化文件，打开 iris.pdf就能够看到生成的图片 方法二 使用 pydotplus 直接生成 iris.pdf 1234import pydotplusdot_data=tree.export_graphviz(clf,out_file=None)graph=pydotplus.graph_from_dot_data(dot_data)graph.write_pdf('iris_2.pdf') 方法三 使用 pydotplus 直接生成 iris.pdf 1234567891011from IPython.display import Image dot_data = tree.export_graphviz(clf, out_file=None, feature_names=iris.feature_names, class_names=iris.target_names, filled=True, rounded=True, special_characters=True) graph = pydotplus.graph_from_dot_data(dot_data) Image(graph.create_png()) dot_data = tree.export_graphviz(clf, out_file=None,filled=True) graph = pydotplus.graph_from_dot_data(dot_data) Image(graph.create_png()) 相关链接ywtail`s blog sklearn决策树可视化 One-Hot Encoding相关链接https://blog.csdn.net/pipisorry/article/details/61193868 https://www.cnblogs.com/wxshi/p/8645600.html one hot编码是将类别变量转换为机器学习算法易于利用的一种形式的过程。 one-hot编码是N位状态寄存器为N个状态进行编码的方式 使用one-hot编码，将离散特征的取值扩展到了欧式空间，离散特征的某个取值就对应欧式空间的某个点。特征之间距离的计算或相似度的计算是非常重要的，而我们常用的距离或相似度的计算都是在欧式空间的相似度计算 数据归一化https://segmentfault.com/a/1190000010300976 相关链接https://www.biaodianfu.com/decision-tree.html","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://lijunkui.netlify.com/categories/深度学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://lijunkui.netlify.com/tags/Python/"},{"name":"DL","slug":"DL","permalink":"https://lijunkui.netlify.com/tags/DL/"},{"name":"ALG","slug":"ALG","permalink":"https://lijunkui.netlify.com/tags/ALG/"},{"name":"sklearn","slug":"sklearn","permalink":"https://lijunkui.netlify.com/tags/sklearn/"},{"name":"One-Hot","slug":"One-Hot","permalink":"https://lijunkui.netlify.com/tags/One-Hot/"},{"name":"ID3","slug":"ID3","permalink":"https://lijunkui.netlify.com/tags/ID3/"}]},{"title":"K-近邻算法","slug":"KNN","date":"2019-02-16T10:18:02.000Z","updated":"2019-03-22T05:43:38.000Z","comments":true,"path":"2019/02/16/KNN/","link":"","permalink":"https://lijunkui.netlify.com/2019/02/16/KNN/","excerpt":"最近邻居法（KNN算法，又译K-近邻算法）是一种用于分类和回归的非参数统计方法","text":"最近邻居法（KNN算法，又译K-近邻算法）是一种用于分类和回归的非参数统计方法 算法实现12345678910111213141516171819202122import numpy as npimport operatordef createDataSet(): group = np.array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]]) labels = ['A', 'A', 'B', 'B'] return group, labelsdef classify0(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] diffMat = np.tile(inX, (dataSetSize, 1))-dataSet sqDiffMat = diffMat**2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances**0.5 sortedDistIndicies = distances.argsort() classCount = &#123;&#125; for i in range(k): voteIlabel = labels[sortedDistIndicies[i]] classCount[voteIlabel] = classCount.get(voteIlabel, 0)+1 sortedClassCount = sorted(classCount, key=lambda x: classCount[x], reverse=True) return sortedClassCount[0][0] 笔记1234567891011121314151617181920import numpy as np# python中自带的sum对一维数组的求和a = np.array([1, 2, 3])print(sum(a)) # 6sum([1, 2, 3])a = np.array([[1, 2, 3], [4, 5, 5]])print(sum(a)) # [5,7,8]# shape[]函数返回数组某个维度的长度b = a.shapec = a.shape[0]e = a.shape[1]print(b, c, e) # (2,3) 2 3a = np.sum([[1, 2, 3], [4, 5, 5]]) # 无参print(a) # 20a = np.sum([[1, 2, 3], [4, 5, 5]], axis=0)# axis=0,表示第一个维度,即按列相加print(a) # [5,7,8]a = np.sum([[1, 2, 3], [4, 5, 5]], axis=1)# axis=1,表示第二个维度,即按行相加print(a) # [6,14] 123456789101112131415161718#dict.get(key, default=None)# 1. 先定义字典dict = &#123;'A': 1, 'B': 2&#125;# 2. 当key值存在于dict.keys()中时，调用get()方法，返回的是对应的value值print(dict.get('A'))# 返回为：1# 3. 当key值不存在于dict.keys()中时，调用get()方法，返回的是Noneprint(dict.get('C'))# 返回为：None# 4. 当default = x时，若key值存在于dict.keys()时，返回dict[key]；若不存在于dict.keys()中时，返回xprint(dict.get('A', 0)) # 1print(dict.get('C', 0)) # 0x = np.array([1, 4, 3, -1, 6, 9])x.argsort()# 输出定义为y=array([3,0,2,1,4,5])。# 我们发现argsort()函数是将x中的元素从小到大排列，提取其对应的index(索引)，然后输出到y。# 例如：x[3] = -1最小，所以y[0] = 3, x[5] = 9最大，所以y[5] = 5。 12345678910111213141516171819202122232425262728#sorted函数:sorted(iterable,key,reverse)#其中iterable表示可以迭代的对象, #key是一个函数，用来选取参与比较的元素，#reverse则是用来指定排序是倒序还是顺序，#reverse=true则是倒序，reverse=false时则是顺序，默认时reverse=falsed = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;&gt;&gt;&gt;sorted(d.keys())['Bob', 'Michael', 'Tracy']&gt;&gt;&gt;sorted(d.values())[75, 85, 95]&gt;&gt;&gt;sorted(d)['Bob', 'Michael', 'Tracy']#默认就是根据key值排序&gt;&gt;&gt;sorted(d,key=lambda x: d[x])#根据value值的大小对key排序['Bob', 'Tracy', 'Michael']#以下返回值是既包含key又包含value的列表,#与上面的区别就是sorted的第一个参数不是d而是d.items(),d.items会把d变成一个可迭代对象.d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;&gt;&gt;&gt;d.items()dict_items([('Michael', 95), ('Bob', 75), ('Tracy', 85)])&gt;&gt;&gt;sorted(d.items(),key=lambda x : x[1])[('Bob', 75), ('Tracy', 85), ('Michael', 95)]&gt;&gt;&gt;d = &#123;'data1':3,'da':1,'dat':2,'data22':4,'aa':3,'ff':0&#125;&gt;&gt;&gt;sorted(d.items(),key=lambda x :(x[1],x[0]))#对dict先根据value排序,value相等的根据key排序[('ff', 0), ('da', 1), ('dat', 2), ('aa', 3), ('data1', 3), ('data22', 4)]sorted(d.items())#根据key值对整个dict排序[('aa', 3), ('da', 1), ('dat', 2), ('data1', 3), ('data22', 4), ('ff', 0)] 1234#lambda 表达式，#通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。add = lambda x,y : x + yprint(add(1, 2)) 遇到的问题1.from numpy import * 遇到警告 2.算法实现的第69行 sorted() 以下代码报错: 1sortedClassCount=sorted(classCount,key=operator.itemgetter(1),reverse=True)","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://lijunkui.netlify.com/categories/深度学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://lijunkui.netlify.com/tags/Python/"},{"name":"DL","slug":"DL","permalink":"https://lijunkui.netlify.com/tags/DL/"},{"name":"ALG","slug":"ALG","permalink":"https://lijunkui.netlify.com/tags/ALG/"},{"name":"KNN","slug":"KNN","permalink":"https://lijunkui.netlify.com/tags/KNN/"}]},{"title":"优化算法与逻辑回归","slug":"Logistic回归","date":"2019-02-03T11:16:07.000Z","updated":"2019-04-11T10:46:50.520Z","comments":true,"path":"2019/02/03/Logistic回归/","link":"","permalink":"https://lijunkui.netlify.com/2019/02/03/Logistic回归/","excerpt":"1.线性回归与逻辑回归2.多元梯度下降3.梯度上升4.正规方程5.Logistic regression","text":"1.线性回归与逻辑回归2.多元梯度下降3.梯度上升4.正规方程5.Logistic regression 线性回归与逻辑回归线性回归在统计学中，线性回归(Linear Regression)是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量的情况称为简单回归,大于一个自变量情况的叫做多元回归。 逻辑回归以胃癌病情分析为例，选择两组人群，一组是胃癌组，一组是非胃癌组，两组人群必定具有不同的体征与生活方式等。因此因变量就为是否胃癌，值为“是”或“否”，自变量就可以包括很多了，如年龄、性别、饮食习惯、幽门螺杆菌感染等。 预测房价 多元梯度下降假设函数 这里n=5,含有5个参数 这里需要注意的是，在原有自变量的基础上，需要主观添加一个均为1的偏移量，即公式中的x0。 假如有两个特征值,即3个参数将会得到如图所示的损失函数 损失函数(代价函数) m:样本数 表示每个theta 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243# coding=utf-8import numpy as npimport randomfrom numpy import genfromtxtdef getData(dataSet): m, n = np.shape(dataSet) trainData = np.ones((m, n)) trainData[:, :-1] = dataSet[:, :-1] trainLabel = dataSet[:, -1] return trainData, trainLabeldef batchGradientDescent(x, y, theta, alpha, m, maxIterations): xTrains = x.transpose() for i in range(0, maxIterations): hypothesis = np.dot(x, theta) loss = hypothesis - y # print loss gradient = np.dot(xTrains, loss) / m theta = theta - alpha * gradient return thetadef predict(x, theta): m, n = np.shape(x) xTest = np.ones((m, n+1)) xTest[:, :, :, :-1] = x yP = np.dot(xTest, theta) return yPdataPath = r\"data.csv\"dataSet = genfromtxt(dataPath, delimiter=',')trainData, trainLabel = getData(dataSet)m, n = np.shape(trainData)theta = np.ones(n)alpha = 0.1maxIteration = 5000theta = batchGradientDescent( trainData, trainLabel, theta, alpha, m, maxIteration) 梯度上升对于梯度下降法来说，在神经网络中用到，最小化误差的一种优化方法 在梯度上升法是在逻辑回归中求概率最大值，即求最大似然函数的最大值用到的方法 算法实现1234567891011121314151617181920212223242526272829303132from numpy import *import numpy as npdef loadDataSet(): dataMat = [] labelMat = [] fr = open('testSet.txt') for line in fr.readlines(): lineArr = line.strip().split() dataMat.append([1.0, float(lineArr[0]), float(lineArr[1])]) labelMat.append(int(lineArr[2])) return dataMat, labelMatdef sigmoid(inX): return 1.0/(1+exp(-inX))def gradAscent(dataMatIn, classLabels): dataMatrix = mat(dataMatIn) labelMatix = mat(classLabels).transpose() m = dataMatrix.shape[0] n = dataMatrix.shape[1] alpha = 0.001 maxCycles = 500 weights = ones((n, 1)) for k in range(maxCycles): h = sigmoid(dataMatrix*weights) error = (labelMatix - h) weights = weights + alpha * dataMatrix.transpose() * error return weights 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#字符串的split用法1.按某一个字符分割&gt;&gt;&gt; str = ('www.google.com')&gt;&gt;&gt; str'www.google.com'&gt;&gt;&gt; str.split('.')['www', 'google', 'com']2.按某一个字符分割，且分割n次。如按‘.’分割1次str.split('.'，1)&gt;&gt;&gt;str&gt;&gt;&gt;['www', 'google.com']3.按某一字符串分割。如：‘||’str = ('WinXP||Win7||Win8||Win8.1')&gt;&gt;&gt; str&gt;&gt;&gt; str.split('||')['WinXP', 'Win7', 'Win8', 'Win8.1']4.按某一字符串分割，且分割n次。如：按‘||’分割2次&gt;&gt;&gt; str = ('WinXP||Win7||Win8||Win8.1')&gt;&gt;&gt; str.split('||',2)['WinXP', 'Win7', 'Win8||Win8.1']#strip()函数1. 当rm为空时，默认删除空白符（包括'\\n', '\\r', '\\t', ' ')&gt;&gt;&gt; a=' Hello World '&gt;&gt;&gt; a' Hello World '&gt;&gt;&gt; a.strip()'Hello World'&gt;&gt;&gt; x='\\t\\r\\npython'&gt;&gt;&gt; x'\\t\\r\\npython'&gt;&gt;&gt; x.strip()'python'2.rm删除序列是只要边（开头或结尾）上的字符在删除序列内，就删除掉。&gt;&gt;&gt; aString='123love'&gt;&gt;&gt; aString'123love'&gt;&gt;&gt; aString.strip('12')'3love'#zeros函数和ones函数&gt;&gt;&gt;from numpy import *&gt;&gt;&gt; a=zeros((3,4))&gt;&gt;&gt; aarray([[ 0., 0., 0., 0.], [ 0., 0., 0., 0.], [ 0., 0., 0., 0.]])&gt;&gt;&gt; from numpy import *&gt;&gt;&gt; a=ones((3,4))&gt;&gt;&gt; aarray([[ 1., 1., 1., 1.], [ 1., 1., 1., 1.], [ 1., 1., 1., 1.]])&gt;&gt;&gt; from numpy import *&gt;&gt;&gt; a=eye(3)&gt;&gt;&gt; aarray([[ 1., 0., 0.], [ 0., 1., 0.], [ 0., 0., 1.]])numpy.eye(N,M=None, k=0, dtype=&lt;type 'float'&gt;)第一个参数：输出方阵（行数=列数）的规模，即行数或列数第三个参数：默认情况下输出的是对角线全“1”，其余全“0”的方阵，如果k为正整数，则在右上方第k条对角线全“1”其余全“0”，k为负整数则在左下方第k条对角线全“1”其余全“0”。&gt;&gt;&gt; a=eye(3,4,k=1)&gt;&gt;&gt; aarray([[0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) 123456789101112131415161718192021222324252627282930313233343536#转置有三种方式，transpose方法、T属性以及swapaxes方法。In [1]: import numpy as npIn [2]: arr = np.arange(20).reshape(4,5)#生成一个4行5列的数组In [3]: arrOut[3]:array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]])In [4]: arr.T #求转置Out[4]:array([[ 0, 5, 10, 15], [ 1, 6, 11, 16], [ 2, 7, 12, 17], [ 3, 8, 13, 18], [ 4, 9, 14, 19]])&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; A = np.arange(16)&gt;&gt;&gt; Aarray([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])&gt;&gt;&gt; A = A.reshape(2,2,4)#将A变换为三维矩阵&gt;&gt;&gt; Aarray([[[ 0, 1, 2, 3], [ 4, 5, 6, 7]], [[ 8, 9, 10, 11], [12, 13, 14, 15]]])&gt;&gt;&gt; A.shape(2, 2, 4)说明这是一个2*2*4的数组（矩阵），返回的是一个元组，可以对元组进行索引，也就是0,1,2A.transpose((0,1,2)) #保持A不变A.transpose((1,0,2)) #将 0轴 和 1轴 交换 正规方程(normal equation)一种直接求解参数的方法 12345678910111213141516171819202122232425262728293031323334octave:1&gt; X = [1,2104,5,1,45;1,1416,3,2,40;1,1534,3,2,30;1,852,2,1,36]X = 1 2104 5 1 45 1 1416 3 2 40 1 1534 3 2 30 1 852 2 1 36octave:2&gt; y = [460;232;315;178]y = 460 232 315 178octave:3&gt; pinv(X&apos;*X)*X&apos;*yans = 188.40032 0.38663 -56.13825 -92.96725 -3.73782 #举例验证octave:4&gt; ex = [1,852,2,1,36]ex = 1 852 2 1 36octave:5&gt; ex*ansans = 178.00 正规方程与梯度下降的比较 推导过程 Logistic regressionLogistic本质上是一个基于条件概率的判别模型(DiscriminativeModel)。利用了Sigmoid函数值域在[0,1]这个特性。直接使用线性回归的输出作为概率是有问题的，因为其值有可能小于0或者大于1,这是不符合实际情况的，逻辑回归的输出正是[0,1]区间。 Logistic 回归通过使用其固有的 logistic 函数估计概率，来衡量因变量（我们想要预测的标签）与一个或多个自变量（特征）之间的关系。 sigmoid 函数Sigmoid 函数是一个 S 形曲线，它可以将任意实数值映射到介于 0 和 1 之间的值，但并不会取到 0/1。然后使用阈值分类器将 0 和 1 之间的值转换为 0 或 1。 决策边界 为什么使用sigmoid function","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://lijunkui.netlify.com/categories/深度学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://lijunkui.netlify.com/tags/Python/"},{"name":"NLP","slug":"NLP","permalink":"https://lijunkui.netlify.com/tags/NLP/"},{"name":"Octave","slug":"Octave","permalink":"https://lijunkui.netlify.com/tags/Octave/"}]},{"title":"词袋和TF-IDF模型","slug":"词袋和TF-IDF模型","date":"2019-01-27T13:04:48.000Z","updated":"2019-03-22T05:49:06.000Z","comments":true,"path":"2019/01/27/词袋和TF-IDF模型/","link":"","permalink":"https://lijunkui.netlify.com/2019/01/27/词袋和TF-IDF模型/","excerpt":"在做文本分类等问题时,需要从大量语料中提取特征,词袋和TF-IDF模型是很好的选择","text":"在做文本分类等问题时,需要从大量语料中提取特征,词袋和TF-IDF模型是很好的选择 词袋模型词袋模型是最原始的一类特征集，忽略掉了文本的语法和语序，用一组无序的单词序列来表达一段文字或者一个文档。可以这样理解，把整个文档集的所有出现的词都丢进袋子里面，然后无序的排出来（去掉重复的）。对每一个文档，按照词语出现的次数来表示文档。 句子1：我/有/一个/苹果 句子2：我/明天/去/一个/地方 句子3：你/到/一个/地方 句子4：我/有/我/最爱的/你 把所有词丢进一个袋子：我，有，一个，苹果，明天，去，地方，你，到，最爱的。这 4 句话中总共出现了这 10 个词。 建立一个无序列表：我，有，一个，苹果，明天，去，地方，你，到，最爱的。并根据每个句子中词语出现的次数来表示每个句子。 句子 1 特征: ( 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ) 句子 2 特征: ( 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ) 句子 3 特征: ( 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 ) 句子 4 特征: ( 2 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 ) TF-IDF 模型这种模型主要是用词汇的统计特征来作为特征集。TF-IDF 由两部分组成：TF（Term frequency，词频），IDF（Inverse document frequency，逆文档频率）两部分组成。 实现在 Python 当中，我们可以通过 scikit-learn 来分别实现词袋模型以及 TF-IDF 模型。并且，使用 scikit-learn 库将会非常简单。这里要用到 CountVectorizer() 类以及 TfidfVectorizer() 类。 12#词袋sklearn.featur_extraction.text.CountVectorizer(min_df=1, ngram_range=(1,1)) min_df :忽略掉词频严格低于定阈值的词 ngram_range :将 text 分成 n1,n1+1,……,n2个不同的词组。比如比如’Python is useful’中ngram_range(1,3)之后可得到 ‘Python’ ， ‘is’ ， ‘useful’ ， ‘Python is’ ， ‘is useful’ ， ‘Python is useful’。如果是ngram_range (1,1) 则只能得到单个单词’Python’ ， ‘is’ ， ‘useful’。 12#Tf-idfsklearn.feature_extraction.text.TfidfVectorizer(min_df=1,norm='l2',smooth_idf=True,use_idf=True,ngram_range=(1,1)） min_df： 忽略掉词频严格低于定阈值的词。 norm ：标准化词条向量所用的规范。 smooth_idf：添加一个平滑 idf 权重，即 idf 的分母是否使用平滑，防止0权重的出现。 use_idf： 启用 idf 逆文档频率重新加权。 ngram_range：同词袋模型 词袋123456789101112131415161718192021222324252627282930313233343536373839#加载词袋类&gt;&gt;&gt; from sklearn.feature_extraction.text import CountVectorizer#调整类的参数&gt;&gt;&gt; vectorizer = CountVectorizer(min_df=1, ngram_range=(1, 1))#建立文本库&gt;&gt;&gt; corpus = ['This is the first document.',... 'This is the second second document.',... 'And the third one.',... 'Is this the first document?']#训练corpus获取词袋特征&gt;&gt;&gt; a = vectorizer.fit_transform(corpus)&gt;&gt;&gt; print(a) (0, 1) 1 (0, 2) 1 (0, 6) 1 (0, 3) 1 (0, 8) 1 (1, 5) 2 (1, 1) 1 (1, 6) 1 (1, 3) 1 (1, 8) 1 (2, 4) 1 (2, 7) 1 (2, 0) 1 (2, 6) 1 (3, 1) 1 (3, 2) 1 (3, 6) 1 (3, 3) 1 (3, 8) 1&gt;&gt;&gt; a.toarray()array([[0, 1, 1, 1, 0, 0, 1, 0, 1], [0, 1, 0, 1, 0, 2, 1, 0, 1], [1, 0, 0, 0, 1, 0, 1, 1, 0], [0, 1, 1, 1, 0, 0, 1, 0, 1]], dtype=int64)#获取特征值 &gt;&gt;&gt; vectorizer.get_feature_names()['and', 'document', 'first', 'is', 'one', 'second', 'the', 'third', 'this'] TF-IDF1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; from sklearn.feature_extraction.text import TfidfVectorizer&gt;&gt;&gt; vectorizer = TfidfVectorizer(... min_df=1, norm='l2', smooth_idf=True, use_idf=True, ngram_range=(1, 1))&gt;&gt;&gt; b = vectorizer.fit_transform(corpus)&gt;&gt;&gt; print(b) (0, 8) 0.4387767428592343 (0, 3) 0.4387767428592343 (0, 6) 0.35872873824808993 (0, 2) 0.5419765697264572 (0, 1) 0.4387767428592343 (1, 8) 0.27230146752334033 (1, 3) 0.27230146752334033 (1, 6) 0.2226242923251039 (1, 1) 0.27230146752334033 (1, 5) 0.8532257361452784 (2, 6) 0.2884767487500274 (2, 0) 0.5528053199908667 (2, 7) 0.5528053199908667 (2, 4) 0.5528053199908667 (3, 8) 0.4387767428592343 (3, 3) 0.4387767428592343 (3, 6) 0.35872873824808993 (3, 2) 0.5419765697264572 (3, 1) 0.4387767428592343&gt;&gt;&gt; b.toarray()array([[0. , 0.43877674, 0.54197657, 0.43877674, 0. , 0. , 0.35872874, 0. , 0.43877674], [0. , 0.27230147, 0. , 0.27230147, 0. , 0.85322574, 0.22262429, 0. , 0.27230147], [0.55280532, 0. , 0. , 0. , 0.55280532, 0. , 0.28847675, 0.55280532, 0. ], [0. , 0.43877674, 0.54197657, 0.43877674, 0. , 0. , 0.35872874, 0. , 0.43877674]])&gt;&gt;&gt; vectorizer.get_feature_names()['and', 'document', 'first', 'is', 'one', 'second', 'the', 'third', 'this']","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"https://lijunkui.netlify.com/categories/自然语言处理/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://lijunkui.netlify.com/tags/Python/"},{"name":"NLP","slug":"NLP","permalink":"https://lijunkui.netlify.com/tags/NLP/"}]},{"title":"结巴中文分词","slug":"jieba-结巴中文分词","date":"2019-01-27T12:04:47.000Z","updated":"2019-03-01T11:17:26.000Z","comments":true,"path":"2019/01/27/jieba-结巴中文分词/","link":"","permalink":"https://lijunkui.netlify.com/2019/01/27/jieba-结巴中文分词/","excerpt":"jieba: Python中很好用的中文分词组件","text":"jieba: Python中很好用的中文分词组件 分词模式 精确模式，试图将句子最精确地切开，适合文本分析； 全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义； 搜索引擎模式，在精确模式的基础上，对长词再次切分，适合用于搜索引擎分词。 功能1.分词 jieba.cut 方法接受三个输入参数: 需要分词的字符串；cut_all 参数用来控制是否采用全模式；HMM 参数用来控制是否使用 HMM 模型 jieba.cut_for_search 方法接受两个参数：需要分词的字符串；是否使用 HMM 模型。该方法适合用于搜索引擎构建倒排索引的分词，粒度比较细 示例 1234567891011121314# encoding=utf-8import jiebaseg_list = jieba.cut(\"我来到北京清华大学\", cut_all=True)print(\"Full Mode: \" + \"/ \".join(seg_list)) # 全模式seg_list = jieba.cut(\"我来到北京清华大学\", cut_all=False)print(\"Default Mode: \" + \"/ \".join(seg_list)) # 精确模式seg_list = jieba.cut(\"他来到了网易杭研大厦\") # 默认是精确模式print(\", \".join(seg_list))seg_list = jieba.cut_for_search(\"小明硕士毕业于中国科学院计算所，后在日本京都大学深造\") # 搜索引擎模式print(\", \".join(seg_list)) 输出 1234567【全模式】: 我/ 来到/ 北京/ 清华/ 清华大学/ 华大/ 大学【精确模式】: 我/ 来到/ 北京/ 清华大学【新词识别】：他, 来到, 了, 网易, 杭研, 大厦 (此处，“杭研”并没有在词典中，但是也被Viterbi算法识别出来了)【搜索引擎模式】： 小明, 硕士, 毕业, 于, 中国, 科学, 学院, 科学院, 中国科学院, 计算, 计算所, 后, 在, 日本, 京都, 大学, 日本京都大学, 深造 2.词典 载入: jieba.load_userdict(file_name) 其中file_name 为文件类对象或自定义词典的路径. 词典格式和 dict.txt 一样，一个词占一行；每一行分三部分：词语、词频（可省略）、词性（可省略），用空格隔开，顺序不可颠倒。 动态修改: 使用 add_word(word, freq=None, tag=None) 和 del_word(word) 可在程序中动态修改词典。使用 suggest_freq(segment, tune=True) 可调节单个词语的词频，使其能（或不能）被分出来。 示例 123456789101112&gt;&gt;&gt; print('/'.join(jieba.cut('如果放到post中将出错。', HMM=False)))如果/放到/post/中将/出错/。&gt;&gt;&gt; jieba.suggest_freq(('中', '将'), True)494&gt;&gt;&gt; print('/'.join(jieba.cut('如果放到post中将出错。', HMM=False)))如果/放到/post/中/将/出错/。&gt;&gt;&gt; print('/'.join(jieba.cut('「台中」正确应该不会被切开', HMM=False)))「/台/中/」/正确/应该/不会/被/切开&gt;&gt;&gt; jieba.suggest_freq('台中', True)69&gt;&gt;&gt; print('/'.join(jieba.cut('「台中」正确应该不会被切开', HMM=False)))「/台中/」/正确/应该/不会/被/切开 3.过滤 利用 jiaba 来做一个简单过滤器，这个在实际的应用中十分常用。比如有的词“的”，“地”，“得”，对数据分析没有什么实际作用，但是文章中大量的这类词又会占据大量的存储资源，因此我们要过滤掉这类词。 示例 123456stopwords = ('的', '地', '得') #停用词表a = []seg_list = jieba.cut(string, cut_all=False)for word in seg_list: if word not in stopwords: a.append(word) 参考文档参考文档","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"https://lijunkui.netlify.com/categories/自然语言处理/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://lijunkui.netlify.com/tags/Python/"},{"name":"NLP","slug":"NLP","permalink":"https://lijunkui.netlify.com/tags/NLP/"}]},{"title":"正向最大匹配算法","slug":"正向最大匹配算法","date":"2019-01-23T14:45:34.000Z","updated":"2019-03-22T05:43:52.000Z","comments":true,"path":"2019/01/23/正向最大匹配算法/","link":"","permalink":"https://lijunkui.netlify.com/2019/01/23/正向最大匹配算法/","excerpt":"正向最大匹配法（Maximum Match Method，MM 法）是指从左向右按最大原则与词典里面的词进行匹配。假设词典中最长词是 m个字，那么从待切分文本的最左边取 m个字符与词典进行匹配，如果匹配成功，则分词, 如果匹配不成功，那么取 m−1 个字符与词典匹配，直到成功匹配为止。","text":"正向最大匹配法（Maximum Match Method，MM 法）是指从左向右按最大原则与词典里面的词进行匹配。假设词典中最长词是 m个字，那么从待切分文本的最左边取 m个字符与词典进行匹配，如果匹配成功，则分词, 如果匹配不成功，那么取 m−1 个字符与词典匹配，直到成功匹配为止。 正向最大匹配法 示例 句子： 中华民族从此站起来了词典：”中华”，”民族”，”从此”，”站起来了” 第一步：词典中最长是 4 个字，所以我们将 “中华民族” 取出来与词典进行匹配，匹配失败。第二步：于是，去掉 “族”，以 “中华民” 进行匹配，匹配失败第三步：去掉 “中华民” 中的 “民”，以 “中华” 进行匹配，匹配成功。第四步：在带切分句子中去掉匹配成功的词，待切分句子变成 “民族从此站起来了”。第五步：重复上面的第 1 - 4 步骤第六步：若最后一个词语匹配成功，结束。最终句子被分成：“中华 / 民族 / 从此 / 站起来了 ” 算法流程 Python实现12345678910111213141516171819202122232425262728# 文本text = '我觉得西亚斯是一所很美丽的大学'# 字典dic = ('美丽', '觉得', '西亚斯', '我', '大学', '是', '一所', '很', '的')# 建立一个空数组存放分词结果words = []# 初始化最长词长度为0max_len_word = 0# 遍历获取最大词长度for key in dic: if(len(key)) &gt; max_len_word: max_len_word = len(key)while len(text) &gt; 0: # word_len先等于最大长度 然后逐渐减小 word_len = max_len_word # 对每个字符串可能有(max_len_word)次循环 for i in range(0, max_len_word): word = text[0: word_len] if word not in dic: word_len -= 1 word = [] else: text = text[word_len:] words.append(word) word = []","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"https://lijunkui.netlify.com/categories/自然语言处理/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://lijunkui.netlify.com/tags/Python/"},{"name":"ALG","slug":"ALG","permalink":"https://lijunkui.netlify.com/tags/ALG/"},{"name":"NLP","slug":"NLP","permalink":"https://lijunkui.netlify.com/tags/NLP/"}]},{"title":"Standard Template Library","slug":"Standard-Template-Library","date":"2018-12-08T11:51:05.000Z","updated":"2019-03-08T12:59:42.000Z","comments":true,"path":"2018/12/08/Standard-Template-Library/","link":"","permalink":"https://lijunkui.netlify.com/2018/12/08/Standard-Template-Library/","excerpt":"STL具有高性能,高移植性和代码重用性高的优点.","text":"STL具有高性能,高移植性和代码重用性高的优点. Sorting sort(startaddress, endaddress) 123456789101112131415161718192021222324#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; void show(int a[]) &#123; for(int i = 0; i &lt; 10; ++i) cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; int main() &#123; int a[10]= &#123;1, 5, 8, 9, 6, 7, 3, 4, 2, 0&#125;; cout &lt;&lt; \"\\n The array before sorting is : \"; show(a); sort(a, a+10); cout &lt;&lt; \"\\n\\n The array after sorting is : \"; show(a); return 0; &#125; Refer std::sort() for more details. Searching binary_search(startaddress, endaddress, valuetofind) 12345678910111213141516171819202122232425262728293031323334353637383940// CPP program to implement // Binary Search in // Standard Template Library (STL) #include &lt;algorithm&gt; #include &lt;iostream&gt; using namespace std; void show(int a[], int arraysize) &#123; for (int i = 0; i &lt; arraysize; ++i) cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; int main() &#123; int a[] = &#123; 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 &#125;; int asize = sizeof(a) / sizeof(a[0]); cout &lt;&lt; \"\\n The array is : \"; show(a, asize); cout &lt;&lt; \"\\n\\nLet's say we want to search for 2 in the array\"; cout &lt;&lt; \"\\n So, we first sort the array\"; sort(a, a + asize); cout &lt;&lt; \"\\n\\n The array after sorting is : \"; show(a, asize); cout &lt;&lt; \"\\n\\nNow, we do the binary search\"; if (binary_search(a, a + 10, 2)) cout &lt;&lt; \"\\nElement found in the array\"; else cout &lt;&lt; \"\\nElement not found in the array\"; cout &lt;&lt; \"\\n\\nNow, say we want to search for 10\"; if (binary_search(a, a + 10, 10)) cout &lt;&lt; \"\\nElement found in the array\"; else cout &lt;&lt; \"\\nElement not found in the array\"; return 0; &#125; std::bsearch in C++ Important STL AlgorithmsC++ Magicians STL Library in c++ STL sort(first_iterator, last_iterator) – To sort the given vector. reverse(first_iterator, last_iterator) – To reverse a vector. *max_element (first_iterator, last_iterator) – To find the maximum element of a vector. *min_element (first_iterator, last_iterator) – To find the minimum element of a vector. accumulate(first_iterator, last_iterator, initial value of sum) – Does the summation of vector elements 123456789101112131415161718192021222324252627282930313233343536373839404142434445// A C++ program to demonstrate working of sort(), // reverse() #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;numeric&gt; //For accumulate operation using namespace std; int main() &#123; // Initializing vector with array values int arr[] = &#123;10, 20, 5, 23 ,42 , 15&#125;; int n = sizeof(arr)/sizeof(arr[0]); vector&lt;int&gt; vect(arr, arr+n); cout &lt;&lt; \"Vector is: \"; for (int i=0; i&lt;n; i++) cout &lt;&lt; vect[i] &lt;&lt; \" \"; // Sorting the Vector in Ascending order sort(vect.begin(), vect.end()); cout &lt;&lt; \"\\nVector after sorting is: \"; for (int i=0; i&lt;n; i++) cout &lt;&lt; vect[i] &lt;&lt; \" \"; // Reversing the Vector reverse(vect.begin(), vect.end()); cout &lt;&lt; \"\\nVector after reversing is: \"; for (int i=0; i&lt;6; i++) cout &lt;&lt; vect[i] &lt;&lt; \" \"; cout &lt;&lt; \"\\nMaximum element of vector is: \"; cout &lt;&lt; *max_element(vect.begin(), vect.end()); cout &lt;&lt; \"\\nMinimum element of vector is: \"; cout &lt;&lt; *min_element(vect.begin(), vect.end()); // Starting the summation from 0 cout &lt;&lt; \"\\nThe summation of vector elements is: \"; cout &lt;&lt; accumulate(vect.begin(), vect.end(), 0); return 0; &#125; count(first_iterator, last_iterator,x) – To count the occurrences of x in vector. find(first_iterator, last_iterator, x) – Points to last address of vector ((name_of_vector).end()) if element is not present in vector. 12345678910111213141516171819202122232425262728// C++ program to demonstrate working of count() // and find() #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() &#123; // Initializing vector with array values int arr[] = &#123;10, 20, 5, 23 ,42, 20, 15&#125;; int n = sizeof(arr)/sizeof(arr[0]); vector&lt;int&gt; vect(arr, arr+n); cout &lt;&lt; \"Occurrences of 20 in vector : \"; // Counts the occurrences of 20 from 1st to // last element cout &lt;&lt; count(vect.begin(), vect.end(), 20); // find() returns iterator to last address if // element not present find(vect.begin(), vect.end(),5) != vect.end()? cout &lt;&lt; \"\\nElement found\": cout &lt;&lt; \"\\nElement not found\"; return 0; &#125; binary_search(first_iterator, last_iterator, x) – Tests whether x exists in sorted vector or not. lower_bound(first_iterator, last_iterator, x) – returns an iterator pointing to the first element in the range [first,last) which has a value not less than ‘x’. upper_bound(first_iterator, last_iterator, x) – returns an iterator pointing to the first element in the range [first,last) which has a value greater than ‘x’. 1234567891011121314151617181920212223242526272829303132// C++ program to demonstrate working of lower_bound() // and upper_bound(). #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() &#123; // Initializing vector with array values int arr[] = &#123;5, 10, 15, 20, 20, 23, 42, 45&#125;; int n = sizeof(arr)/sizeof(arr[0]); vector&lt;int&gt; vect(arr, arr+n); // Sort the array to make sure that lower_bound() // and upper_bound() work. sort(vect.begin(), vect.end()); // Returns the first occurrence of 20 auto q = lower_bound(vect.begin(), vect.end(), 20); // Returns the last occurrence of 20 auto p = upper_bound(vect.begin(), vect.end(), 20); cout &lt;&lt; \"The lower bound is at position: \"; cout &lt;&lt; q-vect.begin() &lt;&lt; endl; cout &lt;&lt; \"The upper bound is at position: \"; cout &lt;&lt; p-vect.begin() &lt;&lt; endl; return 0; &#125; arr.erase(position to be deleted) – This erases selected element in vector and shifts and resizes the vector elements accordingly. arr.erase(unique(arr.begin(),arr.end()),arr.end()) – This erases the duplicate occurrences in sorted vector in a single line. 1234567891011121314151617181920212223242526272829303132333435363738394041// C++ program to demonstrate working of erase() #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() &#123; // Initializing vector with array values int arr[] = &#123;5, 10, 15, 20, 20, 23, 42, 45&#125;; int n = sizeof(arr)/sizeof(arr[0]); vector&lt;int&gt; vect(arr, arr+n); cout &lt;&lt; \"Vector is :\"; for (int i=0; i&lt;6; i++) cout &lt;&lt; vect[i]&lt;&lt;\" \"; // Delete second element of vector vect.erase(vect.begin()+1); cout &lt;&lt; \"\\nVector after erasing the element: \"; for (int i=0; i&lt;5; i++) cout &lt;&lt; vect[i] &lt;&lt; \" \"; // sorting to enable use of unique() sort(vect.begin(), vect.end()); cout &lt;&lt; \"\\nVector before removing duplicate \" \" occurrences: \"; for (int i=0; i&lt;5; i++) cout &lt;&lt; vect[i] &lt;&lt; \" \"; // Deletes the duplicate occurrences vect.erase(unique(vect.begin(),vect.end()),vect.end()); cout &lt;&lt; \"\\nVector after deleting duplicates: \"; for (int i=0; i&lt; vect.size(); i++) cout &lt;&lt; vect[i] &lt;&lt; \" \"; return 0; &#125; next_permutation(first_iterator, last_iterator) – This modified the vector to its next permutation. prev_permutation(first_iterator, last_iterator) – This modified the vector to its previous permutation. 12345678910111213141516171819202122232425262728293031// C++ program to demonstrate working of next_permutation() // and prev_permutation() #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() &#123; // Initializing vector with array values int arr[] = &#123;5, 10, 15, 20, 20, 23, 42, 45&#125;; int n = sizeof(arr)/sizeof(arr[0]); vector&lt;int&gt; vect(arr, arr+n); cout &lt;&lt; \"Given Vector is:\\n\"; for (int i=0; i&lt;n; i++) cout &lt;&lt; vect[i] &lt;&lt; \" \"; // modifies vector to its next permutation order next_permutation(vect.begin(), vect.end()); cout &lt;&lt; \"\\nVector after performing next permutation:\\n\"; for (int i=0; i&lt;n; i++) cout &lt;&lt; vect[i] &lt;&lt; \" \"; prev_permutation(vect.begin(), vect.end()); cout &lt;&lt; \"\\nVector after performing prev permutation:\\n\"; for (int i=0; i&lt;n; i++) cout &lt;&lt; vect[i] &lt;&lt; \" \"; return 0; &#125; distance(first_iterator,desired_position) – It returns the distance of desired position from the first iterator.This function is very useful while finding the index. 12345678910111213141516171819// C++ program to demonstrate working of distance() #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() &#123; // Initializing vector with array values int arr[] = &#123;5, 10, 15, 20, 20, 23, 42, 45&#125;; int n = sizeof(arr)/sizeof(arr[0]); vector&lt;int&gt; vect(arr, arr+n); // Return distance of first to maximum element cout &lt;&lt; \"Distance between first to max element: \"; cout &lt;&lt; distance(vect.begin(), max_element(vect.begin(), vect.end())); return 0; &#125; Useful Array algorithmsArray in C++ STL all_of() 12345678910111213141516// C++ code to demonstrate working of all_of() #include&lt;iostream&gt; #include&lt;algorithm&gt; // for all_of() using namespace std; int main() &#123; // Initializing array int ar[6] = &#123;1, 2, 3, 4, 5, -6&#125;; // Checking if all elements are positive all_of(ar, ar+6, [](int x) &#123; return x&gt;0; &#125;)? cout &lt;&lt; \"All are positive elements\" : cout &lt;&lt; \"All are not positive elements\"; return 0; &#125; any_of() 1234567891011121314151617// C++ code to demonstrate working of any_of() #include&lt;iostream&gt; #include&lt;algorithm&gt; // for any_of() using namespace std; int main() &#123; // Initializing array int ar[6] = &#123;1, 2, 3, 4, 5, -6&#125;; // Checking if any element is negative any_of(ar, ar+6, [](int x)&#123; return x&lt;0; &#125;)? cout &lt;&lt; \"There exists a negative element\" : cout &lt;&lt; \"All are positive elements\"; return 0; &#125; none_of() 12345678910111213141516// C++ code to demonstrate working of none_of() #include&lt;iostream&gt; #include&lt;algorithm&gt; // for none_of() using namespace std; int main() &#123; // Initializing array int ar[6] = &#123;1, 2, 3, 4, 5, 6&#125;; // Checking if no element is negative none_of(ar, ar+6, [](int x)&#123; return x&lt;0; &#125;)? cout &lt;&lt; \"No negative elements\" : cout &lt;&lt; \"There are negative elements\"; return 0; &#125; copy_n() 12345678910111213141516171819202122// C++ code to demonstrate working of copy_n() #include&lt;iostream&gt; #include&lt;algorithm&gt; // for copy_n() using namespace std; int main() &#123; // Initializing array int ar[6] = &#123;1, 2, 3, 4, 5, 6&#125;; // Declaring second array int ar1[6]; // Using copy_n() to copy contents copy_n(ar, 6, ar1); // Displaying the copied array cout &lt;&lt; \"The new array after copying is : \"; for (int i=0; i&lt;6 ; i++) cout &lt;&lt; ar1[i] &lt;&lt; \" \"; return 0; &#125; iota() 12345678910111213141516171819// C++ code to demonstrate working of iota() #include&lt;iostream&gt; #include&lt;numeric&gt; // for iota() using namespace std; int main() &#123; // Initializing array with 0 values int ar[6] = &#123;0&#125;; // Using iota() to assign values iota(ar, ar+6, 20); // Displaying the new array cout &lt;&lt; \"The new array after assigning values is : \"; for (int i=0; i&lt;6 ; i++) cout &lt;&lt; ar[i] &lt;&lt; \" \"; return 0; &#125; 待续","categories":[{"name":"CPP方向","slug":"CPP方向","permalink":"https://lijunkui.netlify.com/categories/CPP方向/"}],"tags":[{"name":"ALG","slug":"ALG","permalink":"https://lijunkui.netlify.com/tags/ALG/"},{"name":"C++","slug":"C","permalink":"https://lijunkui.netlify.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://lijunkui.netlify.com/tags/STL/"}]},{"title":"Qt实践:简易计算器","slug":"Qt实践项目一-简易计算器","date":"2018-12-08T08:17:48.000Z","updated":"2019-03-08T12:59:42.000Z","comments":true,"path":"2018/12/08/Qt实践项目一-简易计算器/","link":"","permalink":"https://lijunkui.netlify.com/2018/12/08/Qt实践项目一-简易计算器/","excerpt":"什么是MVC设计模式,以及MVC设计模式又怎样的优缺点.","text":"什么是MVC设计模式,以及MVC设计模式又怎样的优缺点. MVC 设计模式 优点 同步开发 - 多个开发人员可以同时处理模型，控制器和视图。由于MVC将应用程序的各个组件分离，因此开发人员能够在不同组件上并行工作，而不会相互影响或阻塞。例如，团队可能会将开发人员分为前端和后端。后端开发人员可以设计数据结构以及用户如何与之交互，而无需完成用户界面。相反，前端开发人员能够在数据结构可用之前设计和测试应用程序的布局。 代码重用 - 通过创建彼此独立的组件，开发人员能够在其他应用程序中快速轻松地重用组件。对于具有不同数据的另一个应用程序，可以为一个应用程序重构相同（或类似）的视图，因为视图只是处理数据如何显示给用户。 高内聚 - MVC可以在控制器上对相关操作进行逻辑分组。特定模型的视图也组合在一起。 低耦合 - MVC框架的本质是模型，视图或控制器之间的耦合较低。 易于修改 - 由于责任分离，未来的开发或修改更容易。 模型的多个视图 - 模型可以有多个视图。 缺点 显着的学习曲线 - 关于多种技术的知识成为常态。使用MVC的开发人员需要熟练掌握多种技术。 代码导航 - 框架导航可能很复杂，因为它引入了新的抽象层，并要求用户适应MVC的分解标准。 多伪影一致性 - 将特征分解为三个伪影会导致散射。因此，要求开发人员一次保持多个表示的一致性。 简易计算器的实现 新建项目 文件夹中各个文件的作用 .pro文件：跨平台性的实质所在，其中记录着项目中的所有信息，来到不同的平台下依据该文件生成相同功能效果的可执行程序。 mainwindom.h文件：类的声明 main.cpp 文件 mainwindow.cpp文件：类的定义 .ui文件：界面文件，有两种编辑形式，一种是利用Qt Designer设置部件，另一种是以代码的形式 界面设计 main.h文件123456789101112131415161718192021222324252627282930313233343536373839404142#ifndef EXPR_H#define EXPR_H#include &lt;QDialog&gt;#include &quot;QString&quot;#include &quot;model.h&quot;namespace Ui &#123;class expr;&#125;class expr : public QDialog&#123; Q_OBJECTpublic: explicit expr(QWidget *parent = nullptr); ~expr();private: Ui::expr *ui; model *mode; QString tmp;private slots: void on_btn_0_clicked(); void on_btn_1_clicked(); void on_btn_2_clicked(); void on_btn_3_clicked(); void on_btn_4_clicked(); void on_btn_5_clicked(); void on_btn_6_clicked(); void on_btn_7_clicked(); void on_btn_8_clicked(); void on_btn_9_clicked(); void on_btn_plus_clicked(); void on_btn_min_clicked(); void on_btn_mul_clicked(); void on_btn_div_clicked(); void on_btn_clear_clicked(); void on_btn_equal_clicked();&#125;;#endif // EXPR_H mainwindow.cpp文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include \"expr.h\"#include \"ui_expr.h\"#include \"QString\"#include \"QDebug\"#include \"QDialog\"expr::expr(QWidget *parent) : QDialog(parent), ui(new Ui::expr)&#123; ui-&gt;setupUi(this); this-&gt;mode = new model; this-&gt;tmp=\"\";&#125;expr::~expr()&#123; delete ui;&#125;void expr::on_btn_0_clicked()&#123; if(this-&gt;tmp != \"\") &#123; this-&gt;tmp+=\"0\"; this-&gt;ui-&gt;lbl_display-&gt;setText(this-&gt;tmp); &#125;&#125;void expr::on_btn_1_clicked()&#123; this-&gt;tmp+=\"1\"; qDebug()&lt;&lt;this-&gt;tmp; this-&gt;ui-&gt;lbl_display-&gt;setText(this-&gt;tmp);&#125;void expr::on_btn_2_clicked()&#123; this-&gt;tmp+=\"2\"; this-&gt;ui-&gt;lbl_display-&gt;setText(this-&gt;tmp);&#125;void expr::on_btn_3_clicked()&#123; this-&gt;tmp+=\"3\"; this-&gt;ui-&gt;lbl_display-&gt;setText(this-&gt;tmp);&#125;void expr::on_btn_4_clicked()&#123; this-&gt;tmp+=\"4\"; this-&gt;ui-&gt;lbl_display-&gt;setText(this-&gt;tmp);&#125;void expr::on_btn_5_clicked()&#123; this-&gt;tmp+=\"5\"; this-&gt;ui-&gt;lbl_display-&gt;setText(this-&gt;tmp);&#125;void expr::on_btn_6_clicked()&#123; this-&gt;tmp+=\"6\"; this-&gt;ui-&gt;lbl_display-&gt;setText(this-&gt;tmp);&#125;void expr::on_btn_7_clicked()&#123; this-&gt;tmp+=\"7\"; this-&gt;ui-&gt;lbl_display-&gt;setText(this-&gt;tmp);&#125;void expr::on_btn_8_clicked()&#123; this-&gt;tmp+=\"8\"; this-&gt;ui-&gt;lbl_display-&gt;setText(this-&gt;tmp);&#125;void expr::on_btn_9_clicked()&#123; this-&gt;tmp+=\"9\"; this-&gt;ui-&gt;lbl_display-&gt;setText(this-&gt;tmp);&#125;void expr::on_btn_plus_clicked()&#123; int num = this-&gt;tmp.toInt(); qDebug()&lt;&lt;\"Num1=\"&lt;&lt;num; this-&gt;mode-&gt;setNum1(num); this-&gt;tmp = \"\"; QString ex = this-&gt;ui-&gt;btn_plus-&gt;text(); this-&gt;mode-&gt;setFlag(ex);&#125;void expr::on_btn_min_clicked()&#123; int num = this-&gt;tmp.toInt(); qDebug()&lt;&lt;\"Num1=\"&lt;&lt;num; this-&gt;mode-&gt;setNum1(num); this-&gt;tmp = \"\"; QString ex = this-&gt;ui-&gt;btn_min-&gt;text(); this-&gt;mode-&gt;setFlag(ex);&#125;void expr::on_btn_mul_clicked()&#123; int num = this-&gt;tmp.toInt(); qDebug()&lt;&lt;\"Num1=\"&lt;&lt;num; this-&gt;mode-&gt;setNum1(num); this-&gt;tmp = \"\"; QString ex = this-&gt;ui-&gt;btn_mul-&gt;text(); this-&gt;mode-&gt;setFlag(ex);&#125;void expr::on_btn_div_clicked()&#123; int num = this-&gt;tmp.toInt(); qDebug()&lt;&lt;\"Num1=\"&lt;&lt;num; this-&gt;mode-&gt;setNum1(num); this-&gt;tmp = \"\"; QString ex = this-&gt;ui-&gt;btn_div-&gt;text(); this-&gt;mode-&gt;setFlag(ex);&#125;void expr::on_btn_clear_clicked()&#123; this-&gt;tmp = \"\"; this-&gt;ui-&gt;lbl_display-&gt;setText(\"0\");&#125;void expr::on_btn_equal_clicked()&#123; int num = this-&gt;tmp.toInt(); qDebug()&lt;&lt;\"Num2=\"&lt;&lt;num; this-&gt;mode-&gt;setNum2(num); QString res = this-&gt;mode-&gt;doExpr(); qDebug()&lt;&lt;res; this-&gt;ui-&gt;lbl_display-&gt;setText(res); this-&gt;tmp = \"\";&#125; main.cpp1234567891011#include \"expr.h\"#include &lt;QApplication&gt;#include \"QDialog\"int main(int argc, char *argv[])&#123; QApplication a(argc, argv); expr w; w.show(); return a.exec();&#125; 创建一个Model模型 model的声明 1234567891011121314151617181920#ifndef MODEL_H#define MODEL_H#include \"QString\"class model&#123;private: int num1; int num2; //int result; QString flag;public: model(); void setNum1(int num); void setNum2(int num); void setFlag(QString flag); QString doExpr();&#125;;#endif // MODEL_H model的定义 12345678910111213141516171819202122232425262728293031323334353637383940414243#include \"model.h\"#include \"QString\"model::model()&#123;&#125;void model::setNum1(int num)&#123; this-&gt;num1 = num;&#125;void model::setNum2(int num)&#123; this-&gt;num2 = num;&#125;void model::setFlag(QString flag)&#123; this-&gt;flag = flag;&#125;QString model::doExpr()&#123; int result = 0; if(this-&gt;flag == \"+\") &#123; result = this-&gt;num1 + this-&gt;num2; &#125;else if(this-&gt;flag == \"-\") &#123; result = this-&gt;num1 - this-&gt;num2; &#125; else if(this-&gt;flag == \"*\") &#123; result = this-&gt;num1 * this-&gt;num2; &#125;else if(this-&gt;flag == \"/\") &#123; if(this-&gt;num2 == 0)&#123; return \"ERROR\"; &#125; result = this-&gt;num1 / this-&gt;num2; &#125;else&#123; return QString::number(this-&gt;num1); &#125; return QString::number(result);&#125; 待续","categories":[{"name":"CPP方向","slug":"CPP方向","permalink":"https://lijunkui.netlify.com/categories/CPP方向/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://lijunkui.netlify.com/tags/Qt/"},{"name":"C++","slug":"C","permalink":"https://lijunkui.netlify.com/tags/C/"}]},{"title":"Manjaro","slug":"Manjaro安装","date":"2018-11-15T01:30:29.000Z","updated":"2019-04-11T03:00:38.000Z","comments":true,"path":"2018/11/15/Manjaro安装/","link":"","permalink":"https://lijunkui.netlify.com/2018/11/15/Manjaro安装/","excerpt":"解决Manjaro安装后的基本配置问题.","text":"解决Manjaro安装后的基本配置问题. 基本配置添加国内镜像源 测试镜像源 1sudo pacman-mirrors -i -c China -m rank 修改/etc/pacman.conf文件 123[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 增加archlinuxcn库和antergos库 123456[archlinuxcn]SigLevel = TrustAllServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch[antergos]SigLevel = TrustAllServer = https://mirrors.tuna.tsinghua.edu.cn/antergos/$repo/$arch 或者选择Arch参考 123456[archlinuxfr]SigLevel = NeverServer = http://repo.archlinux.fr/$arch[archlinuxcn]SigLevel = Optional TrustedOnlyServer =https://mirrors.ustc.edu.cn/archlinuxcn/$arch 导入GPG key12sudo pacman -Syy sudo pacman -S archlinuxcn-keyring 输入法 方案一 123456789# 搜狗输入法sudo pacman -S fcitx-sogoupinyinsudo pacman -S fcitx-imsudo pacman -S fcitx-configtool # 图形化的配置工具# 需要添加配置文件`~/.xprofile`，添加如下：export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot;# 重新登录之后就可以使用中文输入法啦 方案二 12345678#安装中文输入法：pacman -S fcitx fcitx-libpinyin kcm-fcitx#修改.xprofileexport GTK2_RC_FILES=&quot;$HOME/.gtkrc-2.0&quot;export LC_CTYPE=zh_CN.UTF-8export XMODIFIERS=@im=fcitxexport GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitx Oh-My-Zsh参考文档参考文档 安装 12345678# zsh install$: sudo pacman -S zsh# oh-my-zsh install curl方式$: sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;# 或者wegt方式sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;# 更换默认的shell$: chsh -s /bin/zsh 设置主题 终端输入命令 open ~/.zshrc找到 ZSH_THEME=”robbyrussell” ，robbyrussell是默认的主题，修改 ZSH_THEME=”样式名称”保存这个文件文件，重新打开终端。 查看主题名称 OhMyZsh自带一些主题，存放在~/.oh-my-zsh/themes目录终端输入 ~/.oh-my-zsh/themes查看 ls vim配置123git clone https://github.com/chxuan/vimplus.git ~/.vimpluscd ~/.vimplus./install.sh https://www.jianshu.com/p/75cde8a80fd7 引导修复1sudo grub-mkconfig -o /boot/grub/grub.cfg 软件网易云音乐 1sudo pacman -S netease-cloud-music Manjaro 桌面调整安装深度桌面1sudo pacman -S deepin deepin-extra 修改/etc/lightdm/lightdm.conf1sudo vim /etc/lightdm/lightdm.conf 1greeter-session=lightdm-deepin-greeter 禁用sddm1systemctl disable sddm 启用lightdm1systemctl enable lightdm 重启1reboot 卸载KDE配套工具(可选)12pacman -Rsc plasmapacman -Rsc kde-applications","categories":[{"name":"系统方向","slug":"系统方向","permalink":"https://lijunkui.netlify.com/categories/系统方向/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://lijunkui.netlify.com/tags/Linux/"}]},{"title":"LBMS 轻量级图书管理系统","slug":"LBMS 轻量级图书管理系统","date":"2018-11-10T06:20:21.000Z","updated":"2019-03-22T05:50:14.000Z","comments":true,"path":"2018/11/10/LBMS 轻量级图书管理系统/","link":"","permalink":"https://lijunkui.netlify.com/2018/11/10/LBMS 轻量级图书管理系统/","excerpt":"该博文的目的是对C++类的概念的理解.","text":"该博文的目的是对C++类的概念的理解. 设计CBook类1234567891011121314151617class CBook &#123;public: CBook() &#123;&#125; ~CBook() &#123;&#125; CBook(char *cName, char *clsbn, char *cPrice, char *cAuthor);public: void WriteData(); void DeleteDate(int iCount); void GetBookFromFile(int iCount);protected: char m_cName[NUM1]; char m_clsbn[NUM1]; char m_cPrice[NUM2]; char m_cAuthor[NUM2];&#125;; 拷贝构造函数函数的实现 123456CBook::CBook(char *cName, char *clsbn, char *cPrice, char *cAuthor) &#123; strncpy(m_cName, cName, NUM1); strncpy(m_clsbn, clsbn, NUM1); strncpy(m_cPrice, cPrice, NUM2); strncpy(m_cAuthor, cAuthor, NUM2);&#125; 添加模块1234567891011121314void CBook::WriteData() &#123; ofstream ofile; ofile.open(\"book.dat\", ios::binary | ios::app); try &#123; ofile.write(m_cName, NUM1); ofile.write(m_clsbn, NUM1); ofile.write(m_cPrice, NUM2); ofile.write(m_cAuthor, NUM2); &#125; catch (...) &#123; throw \"file error occurred \"; ofile.close(); &#125; ofile.close();&#125; 删除模块1234567891011121314151617181920212223242526272829303132333435void CBook::DeleteDate(int iCount) &#123; long respos; int iDataCount = 0; fstream file; fstream tmpfile; ofstream ofile; char cTempBuf[NUM1 + NUM1 + NUM2 + NUM2]; file.open(\"book.dat\", ios::binary | ios::in | ios::out); tmpfile.open(\"temp.dat\", ios::binary | ios::in | ios::out | ios::trunc); file.seekg(0, ios::end); respos = file.tellg(); iDataCount = respos / (NUM1 + NUM1 + NUM2 + NUM2); if (iCount &lt; 0 &amp;&amp; iCount &gt; iDataCount) &#123; throw \"Input number error\"; &#125; else &#123; file.seekg((iCount) * (NUM1 + NUM1 + NUM2 + NUM2), ios::beg); for (int j = 0; j &lt; (iDataCount - iCount); j++) &#123; memset(cTempBuf, 0, NUM1 + NUM1 + NUM2 + NUM2); file.read(cTempBuf, NUM1 + NUM1 + NUM2 + NUM2); tmpfile.write(cTempBuf, NUM1 + NUM1 + NUM2 + NUM2); &#125; file.close(); tmpfile.seekg(0, ios::beg); ofile.open(\"book.dat\"); ofile.seekp((iCount - 1) * (NUM1 + NUM1 + NUM2 + NUM2), ios::beg); for (int i = 0; i &lt; (iDataCount - iCount); i++) &#123; memset(cTempBuf, 0, NUM1 + NUM1 + NUM2 + NUM2); tmpfile.read(cTempBuf, NUM1 + NUM1 + NUM2 + NUM2); ofile.write(cTempBuf, NUM1 + NUM1 + NUM2 + NUM2); &#125; &#125; tmpfile.close(); ofile.close(); remove(\"temp.dat\");&#125; 浏览模块12345678910111213141516171819202122232425262728void CBook::GetBookFromFile(int iCount) &#123; char cName[NUM1]; char clsbn[NUM1]; char cPrice[NUM2]; char cAuthor[NUM2]; ifstream ifile; //这里创建了一个ifile输入流 ifile.open(\"book.dat\", ios::binary); try &#123; ifile.seekg(iCount * (NUM1 + NUM1 + NUM2 + NUM2), ios::beg); ifile.read(cName, NUM1); // char * strncpy ( char * destination, const char * source, size_t num ); if (ifile.tellg() &gt; 0) strncpy(m_cName, cName, NUM1); ifile.read(clsbn, NUM1); if (ifile.tellg() &gt; 0) strncpy(m_clsbn, clsbn, NUM1); ifile.read(cPrice, NUM2); if (ifile.tellg() &gt; 0) strncpy(m_cPrice, cPrice, NUM2); ifile.read(cAuthor, NUM2); if (ifile.tellg() &gt; 0) strncpy(m_cAuthor, cAuthor, NUM2); &#125; catch (...) &#123; throw \"file error occurred\"; ifile.close(); &#125; ifile.close();&#125; 待续","categories":[{"name":"CPP方向","slug":"CPP方向","permalink":"https://lijunkui.netlify.com/categories/CPP方向/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://lijunkui.netlify.com/tags/Qt/"},{"name":"C++","slug":"C","permalink":"https://lijunkui.netlify.com/tags/C/"}]},{"title":"基于Hexo+GitHubPages+Netlify搭建自己的博客","slug":"基于Hexo-GitHub-Netlify搭建自己的博客","date":"2018-10-28T04:30:29.000Z","updated":"2019-01-25T14:16:50.000Z","comments":true,"path":"2018/10/28/基于Hexo-GitHub-Netlify搭建自己的博客/","link":"","permalink":"https://lijunkui.netlify.com/2018/10/28/基于Hexo-GitHub-Netlify搭建自己的博客/","excerpt":"该博文是对整个博客搭建过程的技术总结,重点是Hexo框架的使用.","text":"该博文是对整个博客搭建过程的技术总结,重点是Hexo框架的使用. Hexo Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 GitHubPages GitHubPages是一种静态站点托管服务，旨在直接从GitHub存储库托管您的个人，组织或项目页面。 Netlify Netlify是国外一家提供静态网络托管服务的综合平台，专注于静态网站托管的web服务平台，可以完美的取代Coding。 Netlify完美且免费支持的ssl、域名绑定、http/2和TLS。最重要的就是，管理方式用git方法传递给github、gitlab或者是Bitbucket，然后Netlify就能自动编译并生成静态网站。参考文档 准备工作安装node.js1sudo pacman -S nodejs 安装git1sudo pacman -S git 安装Hexo1npm install -g hexo-cli 检查工作1234nodejs：node -vgit：git -versionHexo：Hexo -v如果提示相应版本号，代表安装成功。 若你遇到了问题，请参考文档 搭建本地博客12mkdir myblogcd myblog 项目初始化项目初始化，会自动生成博客模板，以后写博客只需用 markdown 语法编写对应的 .md 文件即可 1hexo init 安装所有依赖1yarn install 启动本地服务1hexo server 在浏览器输入localhost:4000即可预览博客 关联GitHub 通过 GitHub 的 pages 功能，我们可以把我们的博客托管到 GitHub，而无需去购买云服务器 ,即可构建免费博客。 创建GitHub账户 你可以去GitHub官网按照步骤创建 配置关联GitHub 有了 GitHub 账号之后，登录 GitHub ，创建一个项目，项目名称最好和你本地的项目一致，比如： myblog 点击如图 Settings 开启，GitHub Pages 功能 选择 master branch , 然后 Save 复制你的项目连接，如图 然后在你本地项目根目录找到 _config.yml 文件，粘贴到以下位置 123456DeploymentDocs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/persilee/MyBlog.git branch: master 完成关联 完成以上步骤之后，就可以把自己本地项目推送到 GitHub 托管 安装 hexo-deployer-git 插件（可以通过简单的命令,完成文件生成及推送功能） 1yarn add hexo-deployer-git -S 运行 hexo g （生成本地文件） 1hexo g 运行 hexo d （将本地文件推送到 GitHub ，和 git push 功能相同） 1hexo d 此时，GitHub 应该已给你生成了访问连接，连接格式是: 你的账号名称 + .github.io + \\项目名称,也可以去刚才 GitHubPages 设置页面查看 https 绑定域名 这里采用第三方服务 Netlify 来提供免费的SSL/TLS证书。 新增站点 我们需要注册一个 Netlify 账号,可以选择用 GitHub 注册 点击按钮 New site from Git,来新增站点 然后，点击如图按钮 GitHub 选择你的项目，比如我的 MyBlog 点击 Deploy site 点击 Site settings 点击 Change site name 修改短名称，方便记忆 在点击 Domain management 下的 HTTPS ，按照步骤完成操作，稍等片刻，重新登陆博客，即可看到我们的域名已经上锁 更换主题执行以下命令，安装 next 主题 1git clone https://github.com/iissnan/hexo-theme-next.git themes/next 更改配置文件,修改根目录下的 ./_config.yml 文件，如下 12找到 theme：设置为theme: next 重新生成文件，推送到GitHub 123hexo cleanhexo ghexo d 也可以运行以下命令，启动一个本地服务，调试确定无问题之后再 推送到 GitHub 1hexo s --debug","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://lijunkui.netlify.com/tags/Hexo/"}]}]}